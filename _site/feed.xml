<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>externIE’s Blog</title>
    <description>在这里探索iOS的一切。</description>
    <link>http://externie.github.io/externieblog/</link>
    <atom:link href="http://externie.github.io/externieblog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 07 Apr 2016 11:51:48 +0800</pubDate>
    <lastBuildDate>Thu, 07 Apr 2016 11:51:48 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Modelling of Dispersed Multiphase Flows and Its Applications</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;摘要：&lt;/h1&gt;
&lt;p&gt;This talk will provide an overview on research activities being undertaken at RMIT University, Australia in using both the state-of-the-art computer modelling (computational fluid dynamics) and laboratory experimental (LDA/PIV) techniques to investigate the complex transport processes of various fluid flow and heat transfer problems and two-phase flow systems. The talk will detail their applications relevant to a number of industrial and engineering applications such as in defence (ventilated cavity), nuclear safety (flow boiling), chemical engineering (bubble columns), energy (coal-fired power generation), building construction (fire and dust) and biomedical engineering applications (drug delivery and pollutants through human airways and blood flow system).&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/%E7%90%86%E5%B7%A5/2016/04/01/Modelling-of-Dispersed-Multiphase-Flows-and-Its-Applications/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/%E7%90%86%E5%B7%A5/2016/04/01/Modelling-of-Dispersed-Multiphase-Flows-and-Its-Applications/</guid>
        
        <category>讲座</category>
        
        
        <category>理工</category>
        
      </item>
    
      <item>
        <title>促进有效教学的PPT设计与优化</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;摘要：&lt;/h1&gt;
&lt;p&gt;本课程以有效教学为出发点，围绕正反课件案例，介绍了PPT课件的评价标准；根据媒体理论、教育和心理学相关理论，形成了一套实用性和可操作性都很强的技术规程即“PPT课件设计与优化的基本流程与要领”，并结合典型的案例进行了剖析，同时，介绍了一些PPT的高级技巧在教学中的应用。&lt;/p&gt;

&lt;p&gt;通过学习，帮助老师们形成以“学习为中心”而不是以“技术为中心”的课件设计理念，会根据标准分析评价自己PPT课件的问题，初步学会高效完成PPT课件的设计、制作、美化与优化。&lt;/p&gt;

&lt;p&gt;报名方式：登陆教师教学发展中心网站http://cetl.cqu.edu.cn/jsfz&lt;/p&gt;

&lt;p&gt;在线报名系统，查看项目细则，点击“我要报名”，填写个人信息后完成报名程序。&lt;/p&gt;

&lt;p&gt;咨询方式：65103025，13594620480，李老师&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/%E5%85%B6%E4%BB%96/2016/03/30/%E4%BF%83%E8%BF%9B%E6%9C%89%E6%95%88%E6%95%99%E5%AD%A6%E7%9A%84PPT%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/%E5%85%B6%E4%BB%96/2016/03/30/%E4%BF%83%E8%BF%9B%E6%9C%89%E6%95%88%E6%95%99%E5%AD%A6%E7%9A%84PPT%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        
        <category>讲座</category>
        
        
        <category>其他</category>
        
      </item>
    
      <item>
        <title>基于Node.js的即时通讯工具（移动智能终端课设）</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;摘要：&lt;/h1&gt;
&lt;p&gt;这是一个WebApp，用户间可以进行及时通讯，并且可以群聊，有最近聊天记录，最近联系人，以及消息推送，消息提醒，由于是纯webapp并且采用angular.js作客户端架构，应用可以实现全平台覆盖（良好适配桌面和手机屏幕），无论是win，mac，ios，android还是linux，稍加修改还可以作为android或ios上目前比较流行的hybrid app。主要架构：服务为LeanCloud，客户端视图采用HTML5，B/S连接采用WebSocket协议，客户端基本架构Angular.js。&lt;/p&gt;

&lt;h1 id=&quot;nodejs&quot;&gt;什么是Node.js:&lt;/h1&gt;
&lt;p&gt;Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。Node.
js使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点象C语言中的类库。每一个Node.js的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。&lt;/p&gt;

&lt;h1 id=&quot;websocketwebsocket&quot;&gt;什么是WebSocket协议以及为什么要用WebSocket：&lt;/h1&gt;
&lt;p&gt;在www服务器下我们常用的传输协议有http1.0和http1.1，那么我们的应用为什么要采用WebSocket而不是采用更主流支持更广的http协议呢？其实我们都知道http是一种无状态协议，所谓的无状态就是对事物处理没有记忆能力，并且http通常用于短连接，在不需要状态信息的短连接传输文件它的效率是很高的，但我们需要做的是一个即时通讯工具，需要的是不断的联系，显然http看起来并不是那么合适。那么http协议是不是就不能做到呢，其实也不是，我们照样可以用http来实现或者说模拟实时通讯，我们可以用http建立long poll就是长连接，客户端在没收到消息之前一直保持连接，在收到消息后，再次建立连接等待下一次消息的到来。另一种方法就是采用ajax技术不断的轮询服务器是否有消息等待客户端接收。显然听起来这两种方法都是非常糟糕的，当客户端一多，服务器每时每刻都会收到各种客户端的询问，资源消耗将是非常巨大的。如果我们有服务器主动转发消息的机制不是更好吗，所以我们需要采用WebSocket，因为它只需要客户端与服务器端进行一次握手建立连接就可以了，并且服务器能记住客户端的信息，不需要每次发送消息都要客户端将自己的状态再发给服务器，这么一说用WebSocket协议显然再合适不过了。但是WebSocket的支持并不像http那样广泛，所以再部署项目的时候我们也不能掉以轻心。&lt;/p&gt;

&lt;h1 id=&quot;angularjsangularjs&quot;&gt;什么是Angular.js以及为什么要用Angular.js：&lt;/h1&gt;
&lt;p&gt;Angular.js是谷歌开发的一款Web应用开发框架。它提供了一系列兼容性良好并且可拓展的服务，包括数据绑定，DOM操作，MVC设计模式和模块加载等。它不仅仅是一个类库而是提供了一个完整的框架，避免了和多个类库交互，不再需要熟悉不同的接口，也许性能上比不上jQuery库开发的应用，但是其开发webApp应用的效率是jQuery库不能比的。所以我们在开发webApp的时候通常会选择较为简单的途径－Angular.js，在这个项目中我们还用到了Angular.js中三个不同的模块分别是：1.leancloud-realtime（leancloud SDK 的angular.js包装）；2.ui.router；3.ngMaterial（提供Material风格的UI组件）&lt;/p&gt;

&lt;h1 id=&quot;leancloudleancloud&quot;&gt;什么是leancloud以及我们为什么要用leancloud：&lt;/h1&gt;
&lt;p&gt;leancloud是一套服务，提供免费和收费的后端服务，使开发者更专注于前端应用的设计，实现真正的零后端开发，开发者不用再关心数据和应用服务器，并且leancloud提供的云引擎可以将代码部署在云端执行，更加灵活的满足各种需求。在这个应用中我们的数据通讯以及数据存储推送等等服务都是由leancloud来承担，作为应用开发者我们真正做到只需要关心数据对象本身，而不用关心对象如何进行存储和获取，并且采用leancloud的js-realtime-sdk进行前端的开发。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;系统分析及设计方案：&lt;/h1&gt;
&lt;p&gt;##按模块划分：
我们首先来分析实际发生一段对话需要有几个实体，首先对话需要人物，而且至少是两个和两个以上的人物，其次对话需要有对话内容，在一次对话的每段内容中不仅包括对话消息还有产生对话的时间以及发送人。所以我们如果设计一个即时通讯的应用，至少一定要有两个模块，一个是用户（用来管理用户信息），另一个就是对话（管理对话内容和参与者信息），那么对于一个实用的系统来说我们还需要一个模块用来管理用户和其他用户的对话缓存（很遗憾在这个系统中我们没有实现用户关系系统，我们没有为新用户提供注册ID并参与对话的能力，我们仅仅可以实现已有用户之间的对话通过后台创建不同的对话来实现不同用户或用户群间的简单交流）。
下面是我们的代码结构：
src
├── app
│   ├── components      // 组件
│   │   ├── conversation-cache    // 会话本地缓存 service
│   │   ├── message               // 消息 directive
│   │   ├── reverse-infinite-list // 向上滚动无限加载列表 directive
│   │   └── user                  // 用户相关 service
│   ├── conversation    // 会话 view，app 主界面
│   │   └── conversation-message  // 消息 view，会话 view 的子 view
│   ├── index.config.js // 配置依赖模块
│   ├── index.module.js // js 入口，注册依赖模块，启动 app
│   ├── index.route.js  // 配置路由
│   ├── index.run.js    // 启动 app 的代码
│   ├── index.scss
│   └── login           // 登录 view
├── assets
│   ├── fonts
│   └── images
├── favicon.ico
└── index.html  // 页面入口，ui-view 容器
## 按业务划分：
我们还是采用经典的MVC模式来设计我们的应用，视图方面我们采用html＋css的方式，每个视图有专有的控制器联系视图和后台的model。具体划分如下：&lt;/p&gt;

&lt;p&gt;src
├── app
│   ├── login     // 登陆
│   │   ├── login.html+login.scss    // login界面
│   │   └── login.controller.js                 // login控制器
│   ├── conversation    // 会话 view，app 主界面
│   │   ├── conversation-message  // 消息 view，会话 view 的子 view
│   │   │ ├── conversation-message.html+  conversation-message.css
│   │   │ └── conversation-message.controller.js
│   │   ├── conversation.html+conversation.scss
│   │   └── conversation.js
└── index.html  // 页面入口，ui-view 容器&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;系统实现：&lt;/h1&gt;
&lt;p&gt;## index.module.js:
js 入口，申明依赖模块，配置依赖模块，注册 components 与 views，启动 app。
依赖的 angular 模块有：
- &lt;a href=&quot;https://github.com/leeyeh/angular-leancloud-realtime&quot;&gt;leancloud-realtime&lt;/a&gt;：leancloud realtime SDK 的 angular 包装
- &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui.router&lt;/a&gt;：基于状态的 router
- &lt;a href=&quot;https://material.angularjs.org/&quot;&gt;ngMaterial&lt;/a&gt;：提供 material design UI 组件&lt;/p&gt;

&lt;h2 id=&quot;indexroutejs&quot;&gt;index.route.js&lt;/h2&gt;
&lt;p&gt;配置 ui.router（提供了路由嵌套和视图命名的特性）&lt;/p&gt;

&lt;h2 id=&quot;indexconfigjs&quot;&gt;index.config.js&lt;/h2&gt;
&lt;p&gt;配置其他依赖模块&lt;/p&gt;

&lt;h2 id=&quot;indexrunjs&quot;&gt;index.run.js&lt;/h2&gt;
&lt;p&gt;启动 app 的脚本，通过监听 ui.router 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;stateChangeStart&lt;/code&gt; 事件在视图切换时检查用户登录状态。&lt;/p&gt;

&lt;h2 id=&quot;login&quot;&gt;Login&lt;/h2&gt;
&lt;p&gt;通过 UserService 的 login 方法，最终调用了 SDK 的  &lt;a href=&quot;https://leancloud.cn/docs/js_realtime.html#AV_realtime&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AV.realtime()&lt;/code&gt;&lt;/a&gt;，与实时通讯 server 建立长连接。然后跳转到 conversation 视图。&lt;/p&gt;

&lt;h2 id=&quot;coversation&quot;&gt;Coversation&lt;/h2&gt;
&lt;p&gt;聊天主界面，包括了当前用户的对话列表以及子视图 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConversationMessage&lt;/code&gt;。
这个视图主要做了这些事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取当前用户的所有会话，按照群聊单聊分类。&lt;/li&gt;
  &lt;li&gt;当新用户没有加入任何会话时，自动加入一个预设的群聊会话（defaultConversation）。&lt;/li&gt;
  &lt;li&gt;点击会话列表时让 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConversationMessage&lt;/code&gt; 视图转到对应的会话状态。&lt;/li&gt;
  &lt;li&gt;响应 rt 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt; 事件，维护会话的未读消息数。&lt;/li&gt;
  &lt;li&gt;响应 rt 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt; 事件、rt 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; 事件，响应 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConversationMessage&lt;/code&gt; scope 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;conv.messagesent&lt;/code&gt; 事件，维护消息列表，将其按照最后消息时间排序。&lt;/li&gt;
  &lt;li&gt;点击 Logout 按钮时调用 UserService 的 login 方法进行注销。然后跳转到 Login 视图。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;coversationmessage&quot;&gt;CoversationMessage&lt;/h2&gt;
&lt;p&gt;聊天消息视图，&lt;code class=&quot;highlighter-rouge&quot;&gt;Coversation&lt;/code&gt; 的子视图，由工具栏、消息列表、输入框以及在线用户列表侧边栏组成。其中暂态对话没有「在线用户列表」
」概念。
主要做了这些事情：
- 根据当前的路由信息，获取或创建一个会话。
- 获取该会话的历史消息记录，用户滚到顶部时加载更多历史消息。
- 响应该会话的 &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt; 事件，在列表中显示消息内容。
- （可用的话）获取该会话的在线用户列表，提供本地的查询功能。
- 通知 &lt;code class=&quot;highlighter-rouge&quot;&gt;Conversation&lt;/code&gt; 视图用以清除该会话的未读消息计数。
发送消息，通知 &lt;code class=&quot;highlighter-rouge&quot;&gt;Conversation&lt;/code&gt; 视图用以调整会话列表排序。&lt;/p&gt;

&lt;h2 id=&quot;message&quot;&gt;Message&lt;/h2&gt;
&lt;p&gt;Message directive 封装了消息的样式，需要传入四个属性：
- &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;：根据不同的消息类型展示不同的消息
- &lt;code class=&quot;highlighter-rouge&quot;&gt;previousMessage&lt;/code&gt;：根据上一条消息与当前消息的时间戳决定是否显示消息时间
- &lt;code class=&quot;highlighter-rouge&quot;&gt;isMine&lt;/code&gt;：标记是用户自己发送的消息
&lt;code class=&quot;highlighter-rouge&quot;&gt;onNameClick&lt;/code&gt;：点击消息发送方 ID 的回调&lt;/p&gt;

&lt;h2 id=&quot;reverseinfinitelist&quot;&gt;ReverseInfiniteList&lt;/h2&gt;
&lt;p&gt;封装了向上滚动到容器顶部时触发回调的 directive。&lt;/p&gt;

&lt;h2 id=&quot;user&quot;&gt;User&lt;/h2&gt;
&lt;p&gt;提供用户登录、注销、获取用户登录状态、用户信息的 service。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;区分单聊与群聊&lt;/h2&gt;
&lt;p&gt;LeanMessage 服务本身不区分单聊与群聊，demo 中在会话属性（&lt;code class=&quot;highlighter-rouge&quot;&gt;attr&lt;/code&gt;）中增加了一个标识符 &lt;code class=&quot;highlighter-rouge&quot;&gt;customConversationType&lt;/code&gt; 来标识这是一个单聊会话。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;系统后台的搭建：&lt;/h1&gt;
&lt;p&gt;系统后台的搭建其实十分简单，由于该应用用的是leancloud的服务，我们只需要在我们的帐号里面创建一个应用，在应用－设置－安全中心－Web安全域名里面输入该应用所部属的域名，并且在应用－设置－应用key里面找到appId，在leancloud-runtime和服务器进行连接的时候我们需要绑定应用的appID。在应用的存储页面我们可以看到不同的class，可以认为是我们应用的数据库，存储了所有网络会话信息。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;该系统存在的问题：&lt;/h1&gt;
&lt;p&gt;由于对leancloud后台服务了解的缺失，这个系统并没有一个比较全面的用户系统支持，应用中并不支持用户自由注册和添加删除好友关系，也不支持对话删除功能。同时使用angular.js框架的应用性能并不理想，目前该框架的应用较少，websocket协议的支持面也比较窄，有的服务器不能支持该协议。ngMaterial也是较新的一个angular.js模块，通过实践我们发现在手机UC浏览器上这个项目不能正常运行。如果要想在 Android WebView 中使用，需要注意开启 WebSocket 支持。另外，在部分 Android 机型的 WebView 中不支持 WebSocket 的安全链接，所以需要从 wss 协议转为 ws 协议，关闭 WebSocket 的 SSL。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;项目现况：&lt;/h1&gt;
&lt;p&gt;http://externie.com/dist
请用账号test1登录（不需要输入邮箱地址）&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;参考文献：&lt;/h1&gt;
&lt;p&gt;1.百度百科websocket词条
2.nodejs官网 http://nodejs.org/
3.七步从Angular.js菜鸟到专家 http://developer.51cto.com/art/201308/408586.htm
4.Gulp as a Development Web Server http://code.tutsplus.com/tutorials/gulp-as-a-development-web-server–cms-20903
5.leancloud数据存储文档
6.leancloud实时通讯文档
7.leancloud javascript文档&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Jan 2016 17:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/%E7%B1%BB%E5%88%AB/2016/01/05/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/%E7%B1%BB%E5%88%AB/2016/01/05/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/</guid>
        
        <category>论文</category>
        
        
        <category>类别</category>
        
      </item>
    
      <item>
        <title>iOS应用发布中的一些细节</title>
        <description>&lt;h1 id=&quot;ios&quot;&gt;iOS应用发布中的一些细节&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这几天最大的新闻我想就是&lt;code class=&quot;highlighter-rouge&quot;&gt;巴黎恐怖袭击&lt;/code&gt;了，诶，博主每年跨年都那么虔诚地许下“希望世界和平”的愿望，想不到每年都无法实现，维护世界和平这么难，博主真是有心无力啊，其实芸芸众生的我们能做的大概就是不要闯红灯、不抢小妹妹的甜筒、拉完屎记得冲水、打饭不逃票、不在澡堂小便、不挖人家墙角……其实就是维护世界和平了。&lt;/p&gt;

&lt;p&gt;然而黑客组织&lt;strong&gt;Anonymous&lt;/strong&gt;向ISIS宣战了！&lt;/p&gt;

&lt;p&gt;图0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://externie.github.io/img/post/2015-11-17-pic0.png&quot; alt=&quot;测试测试测试~~~&quot; /&gt;&lt;/p&gt;

&lt;p&gt;威武！&lt;/p&gt;

&lt;p&gt;好吧回归这次文章主题，就列举一些iOS应用发布中个人觉得还蛮容易忽略的一些细节。&lt;/p&gt;

&lt;h2 id=&quot;bundle-identifier&quot;&gt;Bundle identifier&lt;/h2&gt;

&lt;p&gt;Xcode中 &lt;code class=&quot;highlighter-rouge&quot;&gt;Target -&amp;gt; General&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle identifier&lt;/code&gt; ;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;info.plist&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle identifier&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/account/ios/certificate/certificateList.action&quot;&gt;证书中心&lt;/a&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Identifiers&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;App IDs&lt;/code&gt;新建App时的&lt;code class=&quot;highlighter-rouge&quot;&gt;Explicit App ID&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;iTunes Connect&lt;/code&gt;中App信息的&lt;code class=&quot;highlighter-rouge&quot;&gt;套装ID&lt;/code&gt; 必须保持一致！！&lt;/p&gt;

&lt;p&gt;在info.plist或者Xcode里的各种设置中，有很多&lt;code class=&quot;highlighter-rouge&quot;&gt;$(XXX)&lt;/code&gt;这样的像脚本一样的东西，所以补充一点Xcode中的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html&quot;&gt;环境变量&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;certificates&quot;&gt;Certificates证书&lt;/h2&gt;

&lt;p&gt;苹果的证书体系一直都是iOS初学者无尽的梦魇，什么开发证书、发布证书、推送证书，什么ad hoc、内测分发、真机调试……我想每一个iOS初学刚开始接触Apple的证书体系的时候内心是绝壁崩溃并且被心中的草泥马践踏的体无完肤的……。&lt;/p&gt;

&lt;p&gt;其实苹果的证书其实没那么玄乎，很多朋友弄不懂或者过了一段时间又不知道怎么弄了，本质的原因是因为对&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86&quot;&gt;非对称加密(公开密钥加密)&lt;/a&gt;的不理解&lt;del&gt;导致的&lt;/del&gt;，所以为了完全的驾驭苹果的证书，这些基础的知识就是坑你的坎，必须跨过去的。&lt;/p&gt;

&lt;p&gt;网上有各种解释证书中心里面每一种证书作用是什么、怎么创建、怎么使用的，但是这也只能授人以鱼，所以博主不会介绍每一种证书是干嘛的，因为你看前年多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Pass Type ID Certificate&lt;/code&gt; ，去年又有了&lt;code class=&quot;highlighter-rouge&quot;&gt;WatchKit Services Certificate&lt;/code&gt; ，今年又来一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple Pay Certificate&lt;/code&gt;……根本就解释这些证书不完嘛~，所以理解这些证书的统一规律才是王道！所谓&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;万变不离其宗&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多资料都把证书分成两种，分为开发证书(development)、以及发布证书(distribution)。但是博主认为这样分类不是很不科学的，博主的理解的分类是这样的&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;是与开发者或者企业对应的，只要是被&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;签名的App都可以理解为是这个证书对应的开发者开发的。所以一个&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;可以签名多个App。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;呢是与具体的App对应的，一个App的推送证书是无法给另一个App使用的，所以一个&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;只能为一个App签名，更确切的说是这个App需要使用某一项Apple的服务而去产生这个&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以其实苹果每年都添加的证书属于&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;，这些其他证书并不是非必须的，而是使用了苹果的某一项服务时才需要提供的凭证。而&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;是必须的，它签名的APP是属于这个证书的所有者的。&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中我的这个账号默认会有两个不同用途的&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;，有两个App，分别为App1、APP2，以及它们对应的两种用途的推送证书(属于&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;假如我现在需要真机调试App1的推送，那么我只要下载&lt;code class=&quot;highlighter-rouge&quot;&gt;开发根证书&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;App1的开发推送证书&lt;/code&gt;然后双击打开导入钥匙串，然后创建相应profile即可真机调试了；&lt;/p&gt;

&lt;p&gt;假如现在我要发布APP2，那么我只要下载&lt;code class=&quot;highlighter-rouge&quot;&gt;发布根证书&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;APP2的发布推送证书&lt;/code&gt;，然后创建相应地profile即可打包上传App Strore了。(这里因为发布的特殊性，所以发布的电脑必须是创建这个&lt;code class=&quot;highlighter-rouge&quot;&gt;发布根证书&lt;/code&gt;的电脑)。&lt;/p&gt;

&lt;p&gt;profile(描述文件)下文还有篇幅介绍。&lt;/p&gt;

&lt;p&gt;我TM都绕晕了，确实有点麻烦有点复杂，果然iOS开发门槛就是高啊，但是哥就喜欢。&lt;/p&gt;

&lt;h2 id=&quot;app-ids&quot;&gt;App IDs&lt;/h2&gt;

&lt;p&gt;在相应地App的edit中可以添加多套APNs推送证书(其他的证书也类似的)&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这里声明一下，&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;其他证书生成的时候，使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;文件可以和产生&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;的不一致，也就是说产生&lt;code class=&quot;highlighter-rouge&quot;&gt;其他证书&lt;/code&gt;时不一定需要产生&lt;code class=&quot;highlighter-rouge&quot;&gt;根证书&lt;/code&gt;的电脑，所以这里也坑了无数的人调试推送，这个在下文&lt;a href=&quot;#推送的一切&quot;&gt;推送的那些事&lt;/a&gt;详细填坑。&lt;/p&gt;

&lt;h2 id=&quot;provisioning-profiles&quot;&gt;Provisioning Profiles描述文件&lt;/h2&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想这个界面一弹出来的时候，蛋蛋忧伤迎面扑来。然后怒点 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，然后你们团队负责管理证书的基友突然发现证书中心多了好多好乱的证书以及描述文件，然后他爆了一句：what the huck！删掉了带有&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode *&lt;/code&gt;的证书以及描述文件，然后自己又暴力的点了一发&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，然后你突然调试不了了，再暴击&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;键，最后整个团队都只有通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;来真机调试了……。&lt;/p&gt;

&lt;p&gt;所以慎点&lt;code class=&quot;highlighter-rouge&quot;&gt;Fix issue&lt;/code&gt;，如果点击这个选项，聪明的(&lt;del&gt;蠢哭的&lt;/del&gt;)Xcode就会自己管理描述文件，然后各种莫名其妙的带有&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode *&lt;/code&gt;的证书以及描述文件……&lt;/p&gt;

&lt;p&gt;其实只要坚信一点，证书、设备ID、AppID、描述文件都弄对了就绝逼不会出问题的！&lt;/p&gt;

&lt;p&gt;描述文件工作原理&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其实描述文件工作的原理就是在APP打包或者真机调试的时候，让Xcode去检查描述文件里面的BundleID与这个APP的BundleID是否对应。&lt;/li&gt;
  &lt;li&gt;对应的话就会去&lt;code class=&quot;highlighter-rouge&quot;&gt;keyChain&lt;/code&gt;查找有没有相应地证书(所以证书要下载好，并且导入&lt;code class=&quot;highlighter-rouge&quot;&gt;keyChain&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;如果有证书存在的话就会检查证书的类型，如果是开发证书，则会检查调试的设备是否加入了描述文件里面的信任设备ID列表，如果设备没有在描述文件的列表中，则无法调试；如果证书类型是发布证书则不会检查设备ID列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;额外地，如果公司新增了测试机，并且在证书中心的&lt;code class=&quot;highlighter-rouge&quot;&gt;Devices&lt;/code&gt;中添加了新测试机的ID，这样描述文件也要相应地更新，然后重新下载，下载完之后可以先删除旧的描述文件(博主直接覆盖的方式貌似描述文件没有更新啊)，你们可以自己做实验咯，描述文件的路劲&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/XXX/Library/MobileDevice/Provisioning\ Profiles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XXX&lt;/code&gt;你的用户名。&lt;/p&gt;

&lt;p&gt;不要覆盖！记得先删除，可以免除很多问题。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;推送的那些事&lt;/h2&gt;

&lt;p&gt;如果说亿万级用户的微信推送服务并不是企鹅自己定制的而都是由苹果APNs推送的话，那苹果的推送就真的牛逼了，但是有时候测试推送，经常APNs要死不活的，推了半天才到，有一次在APNs沙箱环境怒推1000多条，然后这条队列持续了半个月才推完~~。所以微信、扣扣肯定是定制的推送，有钱就是讨厌，那么任性。&lt;/p&gt;

&lt;p&gt;但是苹果推送的开发是比较简单地，如果没有高级推送需求基本就不用写代码了，只要配置好证书一切OK。&lt;/p&gt;

&lt;p&gt;现在常用的后台server中，一般将推送证书以及推送证书的私钥导出p12交给后台人员即可。&lt;/p&gt;

&lt;p&gt;PHP有点调皮，还需要转换成pem&lt;/p&gt;

&lt;p&gt;生成PHP需要的Pem证书&lt;/p&gt;

&lt;p&gt;准备：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;苹果服务器证书端设置正确！打包证书、描述文件正确！！&lt;/li&gt;
  &lt;li&gt;下载推送证书(cer格式)，导入keyChain，保证私钥存在，不存在去找创建这个证书的电脑要一份过来。&lt;/li&gt;
  &lt;li&gt;从钥匙库导出的&lt;del&gt;根证书&lt;/del&gt;(推送证书)私钥(p12格式)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三步根证书的私钥这里是一个坑！因为一个App的推送证书的创建可以和根证书创建的电脑不同，也就是keyChain产生的&lt;code class=&quot;highlighter-rouge&quot;&gt;certSigningRequest&lt;/code&gt;不一样，所以私钥也是不一样的，在这里生成Pem时，注意要使用推送证书的私钥！&lt;/p&gt;

&lt;p&gt;操作过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把推送证书(.cer)转换为.pem文件，执行命令：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;openssl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x509&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;der&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把推送证书导出的私钥(.p12)文件转化为.pem文件：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;openssl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pkcs12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nocerts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p12&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对生成的这两个pem文件再生成一个pem文件，来把证书和私钥整合到一个文件里：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;推送证书私钥&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PHPPush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后把这个PHPPush.pem给后台基友们，就可以下班啦。&lt;/p&gt;

&lt;p&gt;当然测试推送也比较麻烦，需要模拟真实的推送环境，一般需要后台提供帮助，但是遇到一些后台同事，他们有强烈地信仰着鄙视链的话，很鄙视iOS，心里早就称呼你“死前段”多年了，还那么多事……&lt;/p&gt;

&lt;p&gt;所以关于调试推送，博主教你自己推自己！不麻烦别人。&lt;/p&gt;

&lt;p&gt;只要拷贝这段代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// devicetoken
&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;你的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 私钥密码，生成pem的时候输入的
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123456&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 定制推送内容，有一点的格式要求，详情Apple文档
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;你收到一个新订单&#39;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aps&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sound&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;badge&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_type&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;新订单提醒&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;你收到一个新消息&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream_context_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stream_context_set_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_cert&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pem&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//记得把生成的push.pem放在和这个php文件同一个目录
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream_context_set_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passphrase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream_socket_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//这里需要特别注意，一个是开发推送的沙箱环境，一个是发布推送的正式环境，deviceToken是不通用的
&lt;/span&gt;	&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//gateway.sandbox.push.apple.com:2195&#39;, $err,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//&#39;ssl://gateway.push.apple.com:2195&#39;, $err,
&lt;/span&gt;	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STREAM_CLIENT_CONNECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STREAM_CLIENT_PERSISTENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to connect: $err $errstr&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APNS&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;n&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;n&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successfully&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将上面的代码复制，保存成push.php&lt;/p&gt;

&lt;p&gt;然后根据上面“生成PHP需要的Pem证书”的步骤生成push.pem&lt;/p&gt;

&lt;p&gt;两个文件放在同一目录&lt;/p&gt;

&lt;p&gt;执行下面的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;DavidDay&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;php&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APNS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successfully&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delivered&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是就推送成功了呢？呵呵哒&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;打包、分发及内测&lt;/h2&gt;

&lt;p&gt;关于打包是有很多姿势的，每个人都有各自的喜好，大部分规矩的做法都是使用Xcode的一条龙服务的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选择相应地描述文件、证书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择ARM架构机型(模拟器是Intel架构的，真机是ARM架构的，不能通用)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;product -&amp;gt; archive&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后就可以选择导出ipa在第三方平台分发测试或者上传App Stroe审核了&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的做法比较保险，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;archive&lt;/code&gt; 只会编译出真机的二进制码，所以不用担心导出的ipa真机装不起。&lt;/p&gt;

&lt;p&gt;另一种姿势是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xcodebuild&lt;/code&gt; 工具，纯Shell编译，比较不好处理错误，但是逼格满满啊，想详细了解这种姿势的可以看看&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html&quot;&gt;官方文档&lt;/a&gt; ，或者参考这位同学的&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4097487.html&quot;&gt;分享&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然嘛，博主作为拖拖派的忠实拥趸，博主打包ipa的时候是这样的：&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-17-pic6.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随时build随时转ipa。&lt;/p&gt;

&lt;p&gt;分发内测一般都会使用第三方的平台，&lt;a href=&quot;fir.im&quot;&gt;fir&lt;/a&gt;、&lt;a href=&quot;http://www.pgyer.com/&quot;&gt;蒲公英&lt;/a&gt; 都很好呀~&lt;/p&gt;

&lt;p&gt;关于提交审核这里，一般archive过去了，证书正确都没问题的，当然还是要检查项目是否调用了私有API，之前用&lt;a href=&quot;http://revealapp.com/&quot;&gt;reveal &lt;/a&gt; ，提交应用的时候忘了移除，千不该万不该的还是用了Xcode的upload工具，也不报错，在iTunesConnect中构建版本也出现了，只是状态“正在处理”，一般这个状态持续10分钟~2个小时就会通过了，然后博主自信关机下班，想不到第二天构建版本还是“正在处理”，然后猜想是不是iTunes出问题了又怒传了N个包，依然是“正在处理”，后来准备发邮件，打开邮箱，尼玛！&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;原来调用了私有接口，忘记移除reveal了~，回顾起来这里有三个大坑，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xcode的上传工具很辣鸡！！很多错误都无法扫描出来，所以切记 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Application Loader&lt;/code&gt; ，速度快，错误报告也精准。&lt;/li&gt;
  &lt;li&gt;iTunesConnect的错误状态几乎没有，一般只有两个状态 “正在处理”、“成功”，所以如果超过两个小时仍然是“正在处理”，那么极有可能包出问题了！&lt;/li&gt;
  &lt;li&gt;记住关注邮件！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;打包项目证书选择必须正确 (Xcode7以下 选择项目编译target为Iphone Device 不要连接手机 否则会 ，Xcode7中不需要拔出真机，因为多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;build only device&lt;/code&gt; 的选项）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;err&quot;&gt;编译&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;选错了&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;报错&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;ITMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90530&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid MinimumOSVersion. Apps that only support 64-bit devices must specify a deplyment target of 8.0 or later&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IMTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90208&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid Bundle. The bundle xxx.app does not support the minimum OS version specified in the Info.plist&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IMTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90502&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid Bundle. Apps that only contain the arm64 slice must also have&#39;arm64&#39; in the list of UIRequiredDeviceCapabilities in Info.plist &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;突然想起我哥说的一句话&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有时候有些女人就像饭堂饭菜，虽然难吃，但是去晚了也会没有的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;珍惜身边的人。&lt;/p&gt;

&lt;p&gt;感觉这个总结什么鬼？有点伤感，嗯，iOS应用的发布，每个从业者都应该能够熟练的对发布进行操作和意外处理的。&lt;/p&gt;

&lt;p&gt;没钱结婚。&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Nov 2015 20:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/2015/11/17/iOS%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/2015/11/17/iOS%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</guid>
        
        <category>拾遗集</category>
        
        
      </item>
    
      <item>
        <title>半年的iOS代码生活</title>
        <description>&lt;h1 id=&quot;ios&quot;&gt;半年的iOS代码生活&lt;/h1&gt;

&lt;p&gt;在高考大军中拼杀过，也在大学校园中荒芜过，曾经低迷消沉，也常满怀壮志…… 但是最多的还是被称为小伙子以及自称为iOS工程师！博主就是这种喜闻乐见的这类人，实习一年后在2015年的毕业季顺利拿到了自己向往的一家创业公司的offer，也许相比很多毕业季的同学职场上顺利许多，但当深夜来临，显示器熄灭后望着荧幕出神的时候，毕业季我错过了很多也许一辈子都不会再相见的同学们的合影。半年里真正领略到了企业项目的开发的艰辛，以及团队协作的魅力，有太多太多的要说，终将其汇成一句话：哥加班半年后终于回来了！&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-11-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;半年时间，反正撸啊撸段位已经是万劫不复了，iOS9一发布加班的觉悟早有了，潜伏的XCodeGhost也被拎出来了，各种被脱裤的同行大佬们也是尿了一地，哥也被吓了一哆嗦，赶忙修改了1024的账号密码…… 2015年就是伴随这些琐事发展着，但是博主作为一个初入职场半年的工作总结当然不会是简单地流水账。&lt;/p&gt;

&lt;p&gt;我知道你们都惦记着什么是1024，1024就是，呵呵，就是一款妈妈都说好玩的游戏啊~。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;学习&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;干挨踢的学会学习远比你死背一个功能的代码来的有用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在iOS学习中去尝试体会Cocoa模式，多留意Cocoa中的框架的类，他们的命名都有规范，相似抽象的对象会有相似的方法或者写法，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Mutable&lt;/code&gt;的类可能都有&lt;code class=&quot;highlighter-rouge&quot;&gt;addXX&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;appendXX&lt;/code&gt;方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;类型的类可能都会有&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerateXX&lt;/code&gt;的遍历方法……，又比如一个类的功能如果注重过程的话，苹果会选择使用&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;的方式，注重结果的话则会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; ，学会总结比较、触类旁通、举一反三！&lt;/p&gt;

&lt;p&gt;如果你能做到对Cocoa模式很熟悉的话，那么最新的3DTouch功能直接看类的头文件就会用了。&lt;/p&gt;

&lt;p&gt;并且，第三方优秀的、热门的库都会遵循这一套编写规范，所以使用起来或者修改起来也才能够游刃有余！除了&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot;&gt;ReactiveCocoa&lt;/a&gt;之流除外。。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;学习时候看一本书远没有敲一个项目来的有效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看书的时候总是会犯一个毛病，就是一看就懂，一写就懵。所以学习技术，我更推荐的是实践检真知！敲出来的代码才是学习到的，因为你在电脑前，你遇到不懂的你可以立刻Google，看到感兴趣的新类可以直接&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左键&lt;/code&gt;查看文档或者&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左键&lt;/code&gt;直接摆出头文件一览无遗！&lt;/p&gt;

&lt;p&gt;当然&lt;a href=&quot;https://developer.apple.com/wwdc/&quot; target=&quot;_blank&quot;&gt;WWDC&lt;/a&gt;别忘了看看，这是iOS最前沿的技术教学，即使听不懂也没关系，把音频外放，同事问你：哇，你听得懂呀。你微微一笑答道：听不懂。留下认真聆听却似享受的一道背影给同事，那可是满满的逼格。。呵呵，其实不然，视频中有大量PPT，有关键字，拿出来Google一番，再敲打一番，肯定你心中会觉得不虚此举哈，这样也锻炼了英文水平，这样的一波绝逼不亏呀。&lt;/p&gt;

&lt;p&gt;说到英文，这个是技术进阶的基础，不要畏惧，刚开始看一篇英文文档可能花费你一天的时间，但是这才是第一手资料！国内译者的水平毕竟参差不齐，谬误在所难免，而且二手的资料，对于充满处女情结的你能接受么？能忍么？所以百度还是用来搜搜绯闻、床照之流就好，技术索引真不是它的强项，搜出来的东西都是&lt;code class=&quot;highlighter-rouge&quot;&gt;deprecated&lt;/code&gt;的，实在浪费感情。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nshipster.com/&quot; target=&quot;_blank&quot;&gt;NSHipster&lt;/a&gt;、&lt;a href=&quot;https://www.objc.io/&quot; target=&quot;_blank&quot;&gt;Objc.io&lt;/a&gt; ……都是不错的去处，大量的紧巴巴的干货，他们都有中文版，但是最新的资料的中文版还是会相对滞后。&lt;/p&gt;

&lt;p&gt;再一个就是大婶们的博客，一天不读都浑身难受！&lt;/p&gt;

&lt;p&gt;之前拜阅&lt;a href=&quot;http://blog.devtang.com/&quot; target=&quot;_blank&quot;&gt;唐巧Boy&lt;/a&gt;的新书的时候，有一个博客列表非常不错，强势插入我的&lt;a href=&quot;http://feedly.com/&quot; target=&quot;_blank&quot;&gt;Feedly&lt;/a&gt;列表，我自己也有一些关注的大婶也加入了列表当中，这里给出分享OPML&lt;a href=&quot;http://daiweilai.github.io/attach/feedly.opml&quot;&gt;拿去玩&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;沙龙、研讨什么的可以适当参加，看看荧幕外的世界，不要老说没有搞iOS的姑娘。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;团队&lt;/h2&gt;

&lt;p&gt;讲一个故事：从前有个产品经理，他修改了3次需求，第二天他死了。&lt;/p&gt;

&lt;p&gt;博主只想说的是，若不是博主心慈，我想我公司的产品经理已经死完后投胎又死一百次了。&lt;/p&gt;

&lt;p&gt;我们都知道项目完成的水平直接由团队中是否有高效的协作而决定，也许有很多程序员长期的孤高冷艳惯了，他们说自己不需要团队！自己一个人就可以搞定一切，自己是UI、UE、产品、编码、测试甚至后端一条龙拿下，但是你将没有女朋友！！！&lt;/p&gt;

&lt;p&gt;团队协作远比个人的英雄主义更有魅力，个人认为！&lt;/p&gt;

&lt;p&gt;当下的快速迭代的大环境下，企业级开发下英雄主义是不太可取也不太可行的，所以融入团队，学会交流是工作顺利进展的保证；&lt;/p&gt;

&lt;p&gt;当然团队协作中是否高效是否愉快就需要交流技巧了，每个人都有自恋的情节，即使是自己的工作技能也是如此，所以世界上存在着各种鄙视链&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-11-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举一个简单地例子吧&lt;/p&gt;

&lt;p&gt;公司常见撕逼的三个部门：研发部、产品部、市场部&lt;/p&gt;

&lt;p&gt;研发的看不起产品、市场，觉得他们都不懂技术，只是天马行空，遇到Bug还大惊小怪……&lt;/p&gt;

&lt;p&gt;产品的觉得自己的设计是天才的设定，参考了社会伦理学，色彩心理学，严格的人体工学设计……反驳自己的都是傻逼……&lt;/p&gt;

&lt;p&gt;市场的觉得自己深入客户，自己才是最了解这个产品市场的，所产品应该按自己的市场为导向，颜色不对，字体客户肯定不喜欢，改改改……&lt;/p&gt;

&lt;p&gt;在排除消极因素，投机倒把的极个别人存在，团队中的成员还是希望共同的目标能够完美的实现的，也就是说其实我们的“争吵”也是为了更好的产品，但是“争吵”的度确实很难把握，难免就因为工作却伤了私下的感情，这也是离职中众多原因之一，频繁的离职却会使得你的职业生涯成长增加时间成本，所以更好的工作方式是“学会交流”。&lt;/p&gt;

&lt;p&gt;“学会交流”不单单是工作中用到，这也是我们的一生的学问！&lt;/p&gt;

&lt;p&gt;例如有时候，产品部门不是很负责任的频繁变更需求，这可苦了研发的成员，你便可以玩笑似的给他讲一个故事：从前有个产品经理，他修改了3次需求……，我想这样的诙谐即会是的工作氛围愉悦许多也可能让产品的同事知道自己不负责任行为的影响。&lt;/p&gt;

&lt;p&gt;但是需求变更，这个是研发一直要面对课题，所以你必须学会“预置性开发”，预置性包括使用一些优秀的设计模式的使用降低模块间的耦合，增加系统维护的灵活性，也可以有类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Placeholder&lt;/code&gt;的编码技巧，来随时应对不期而遇的需求变更，具体的做法，这也许需要另开一篇博文来讲述。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;健康&lt;/h2&gt;

&lt;p&gt;如果还没有升职加薪，当上总经理，出任CTO，迎娶白富美，走向人生巅峰。却出师未捷身先死，这个都不太好玩，身边的同事以及博主自己都有或多或少的职业病产生了，博主躬亲力行地验证了一个道理：樯橹灰飞烟灭！别说撸代码还真的很带感，根本停不下来，所以最后颈椎，肩膀就是各种不适。说多都是泪，不过后来博主秉承了国人”先污染后治理”的方针，总算把身子调过来了，秘笈如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;练此功，不强制自宫&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;好吧，这才是第一条，”不可久坐”x循环3次！！很重要，久坐流入脑子的血液会增加，从而造成下肢浮肿。由于久坐只限于局部肌肉活动，缺乏全身较大肌群动作，时间一长，久不动作的肌肉会逐步萎缩，机能衰退，还会使心、肺的后备能力降低，不能适应肌肉活动对血液循环和氧气供应的要求，一动就会心跳气急。肌肉长期不活动，热量消耗少，会加重脂肪和糖的代谢障碍，导致身体过分肥胖、动脉硬化及糖尿病。而且久坐一般皮肤质量较差，长时间静坐，受压血液流通不畅，易引起臂部瘙痒和隐痛，伏案工作者更甚，长期下去易导致颈椎炎，肩周炎，腰椎突出，脊柱变弯……我编不下去了，就问你怕不怕！！！所以多起身活动往非技术部走走，不然就会生病的哟(认不出雌性生物了)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坐姿&lt;/p&gt;

    &lt;p&gt;图2&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-11-11-pic3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;尝试全键盘操作，多记记几个快捷键世界就安静了，反正博主的magic mouse干电池已扣，什么你的是最新款的鼠标没干电池？那为了你的健康着想拿给博主用吧，可减少手腕以及肩膀劳损的风险。这里分享一个Mac屏幕效率工具&lt;a href=&quot;http://www.irradiatedsoftware.com/&quot; target=&quot;_blank&quot;&gt;SizeUp&lt;/a&gt; 可减少鼠标的使用！&lt;/li&gt;
  &lt;li&gt;运动运动运动！不要在被人黑了，老是被黑码农，油头垢面，肾虚患者……有意思么？我们是改变世界的工程师！不要再穿拖鞋上班了！！大家薪水都不低，穿得体面点吧。你可以和博主一样帅的。&lt;/li&gt;
  &lt;li&gt;努力陪伴回你身边一直陪伴着你的人，那使你的精神最远是最佳的状态！什么？那就多打打电话给你妈妈吧，那是最美的人。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;追求&lt;/h2&gt;

&lt;p&gt;不要担心30岁要转行，不要认为30K就是终点，不要一天工作30个小时。保持初心。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;O ever youthful,O ever weeping.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;博主新开了一个博客系统，托管在了Github.io上，喜闻乐见的Jekll加借鉴&lt;del&gt;(抄袭)&lt;/del&gt;的精美主题构建而成，反正样子应该还看得过去，如果有朋友有兴趣想了解iOS程序员为何日撸万行代码？数百奇巧淫技如何施展？无数干货为何频频送出？究竟编译器背后又隐藏着什么？这一切的背后是技术与生活的碰撞还是高效与投机的权衡？我真TM编不下去了，欢迎前往 &lt;a href=&quot;http://daiweilai.github.io&quot; target=&quot;_blank&quot;&gt;[任意门]&lt;/a&gt;围观。&lt;/p&gt;

&lt;p&gt;严肃地，如果你刚开始学习iOS开发或许可以从博主这里得到一些半干货。&lt;/p&gt;

&lt;p&gt;生活愉快！&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Nov 2015 20:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/2015/11/11/%E5%8D%8A%E5%B9%B4%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E7%94%9F%E6%B4%BB/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/2015/11/11/%E5%8D%8A%E5%B9%B4%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E7%94%9F%E6%B4%BB/</guid>
        
        <category>闲暇集</category>
        
        
      </item>
    
      <item>
        <title>iOS各种调试技巧</title>
        <description>&lt;h1 id=&quot;ios&quot;&gt;iOS各种调试技巧&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近博主临近毕业季，为了完美的写一篇毕业论文，真是：“锄禾日当午，汗滴禾下土”&amp;lt;—— 这句诗跟毕业我写毕业论文没任何一毛钱关系，我就是突然想吟湿了。不过博主作为网络工程专业的好青年，曾经的愿望和理想就是在下水道干出一番轰轰烈烈的大事业，没错是就是下水道，我们的征途在下水道！！不过大家别误会，我不是忍者龟的脑残粉！听我继续说！我想的是等我在各大排水系统各大下水道功成名就的时候，我就可以指着一个井盖对我的孙子说：“诺 那个下面的通信光缆是爷爷我接的！！” 我满脸自豪地接受着这孙子的敬仰！但是啊，曾经的愿望都实现不了了，我深深爱着的地下通信光缆啊，曾经多少个夜晚泪水打湿了我的毕业论文，渲染开的笔墨那都是哥逝去的青春啊。&lt;/p&gt;

&lt;p&gt;因为生活就像开了博主一个玩笑，让博主遇到了一种鸡，那是一种特殊品种的鸡，它叫做逼优鸡！！就是这只鸡让博主无缘无故的成了一只APM超200的野生究极程序猿！！吼~ 嗷~，把博主带离了下水道！并且与这只鸡踏上另一端征途！临走的时候，下水道的通信光缆就交给你们了，肥皂基友们(网络工程的基友们)！！我靠，他们竟然在打印店花了50块钱就直接买了一套深度豪华毕业论文套餐！里面包含了论文，工程制图，CAD，报价清单，拓扑结构……最重要的是老板承诺不需任何修改，直接可以通过毕业答辩，不通过来年免费再提供一套论文，最贴心的是竟然支持通过再付款！！，&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;老子写论文写了半个月像狗一样，他们竟然直接就买了！就这么买过去了！！对得起老师的谆谆教诲、自己的辛苦付出和父母的期待么？我就问你们惭愧不惭愧？为什么买的时候不喊上我？泪已淌干~&lt;/p&gt;

&lt;p&gt;扯蛋过多容易肾亏&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;逼优鸡&lt;/h2&gt;

&lt;p&gt;终于来到了大家期待的正片，今天我就要和大家讲我和逼优鸡的故事，逼优鸡它优雅低调，它身材玲珑，藏匿在黑暗处，挑动着我的欲望！曾多个日夜博主都……（擦！尼玛，逼优鸡是什么鬼？说好的技术文章?）同学你真的(biè)急，你先坐下，先把鞋子穿好！我说的逼优鸡它的英文名叫做(Bug)，它挺(T)美(M)的(D)……&lt;/p&gt;

&lt;p&gt;歌仔唱的好：&lt;/p&gt;

&lt;p&gt;多少猿曾被它夺走年轻的容颜&lt;/p&gt;

&lt;p&gt;多少猿曾在它面前亮门秃了头&lt;/p&gt;

&lt;p&gt;多少Bug曾经生命中来了又还&lt;/p&gt;

&lt;p&gt;可知一生有你我都陪在你身边&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;无数个夜晚你揪着头发和Bug撕咬的情景博主可以体会，所以这次的这篇文章博主就要给大家整理一个调教iOS逼优鸡的方法豪华套餐！！放心！绝对的深度豪华，因为已经加入肯德基豪华午餐~咳咳~其实是因为逼优鸡(Bug)对于我们毕竟是除了老婆之外第二可怕的存在！我们必须要练就铜头铁臂十八般武艺，祭练奇门巧技各种大杀！方可与之周旋并将之歼灭！好！跟着博主一起装逼一起飞吧！！！！&lt;/p&gt;

&lt;p&gt;第一步：&lt;/p&gt;

&lt;p&gt;我看大家蓬头垢面的就知道大家刚刚也才debug回来 ，我们就先写个hello world压压惊把！&lt;/p&gt;

&lt;p&gt;第二步&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;知己知彼 百战不殆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此处为大量Copy！不喜请喷！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The software doesn’t do something that the product specification says it should do.&lt;/p&gt;

  &lt;p&gt;The software does something that the product specification says it shouldn’t do.&lt;/p&gt;

  &lt;p&gt;The software does something that the product specification doesn’t mention.&lt;/p&gt;

  &lt;p&gt;The software doesn’t do something that the product specification doesn’t mention but should.&lt;/p&gt;

  &lt;p&gt;The software is difficult to understand, hard to use, slow, or in the software tester’s eyes will be viewed by the end user as just plain not right.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;我不是英文教师，请大家自行切换多语言阅读模式。&lt;/p&gt;

&lt;p&gt;也还有有人粗暴的定义 ”Bug就是错误“，除了世界上第一只Bug是飞进去的那只虫子外，其他Bug毋庸置疑那都是程序员们自己生下来的！程序员们自己犯的错误！如果说一个软件作品(请尊重你自己的作品，不要喊他们”产品”或者”项目”)是程序员们自己的孩子，那么Bug就是这个孩子的生的病，有病得治，药不能停！生病有各种治疗方法，物疗，理疗，化疗，心理疗……那么“治疗”Bug也是有多中方法的！下面博主会一一列举！惩治这些个Bug之前，博主要先阿拉巴拉一番，遇到Bug也是一件比较哔了狗了的事情，你要知道任何人都会生病，没有例外！所有任何代码都有Bug这是定理，我们首先要从心态上端正Bug这件事情，我们可以理解为缺憾也是一种美，就像阿雨说的“没有皱纹的祖母是可怕的，没有白发的老者是让人遗憾的。没有废墟的人生太累了，没有废墟的大地太挤了，掩盖废墟的举动太伪诈了。”Debug是为了证明程序有错，而不是证明程序无错误；所以我们要做到临Bug而不惧者,圣人之勇也！所以我们要做到战略上藐视它，战术上重视它！你要心理默念Bug其实挺(T)美(M)的(D)!anyway 无Bug不生活！！&lt;/p&gt;

&lt;h2 id=&quot;bug&quot;&gt;抽刀断Bug&lt;/h2&gt;

&lt;p&gt;断点，（我求你们不要想到张敬轩，阿轩他容易么，小受又怎么了？你们这帮人真是的！！），我要说的断点是BreakPoint！基本上不是残废的IDE都具有断点调试功能吧！尤其是XCode，我们家的IDE断点调试功能可是强中又是强中手！在这之前大家可以先了解一下哈子是断点？它怎么实现的？工作原理怎么样的？博主就献丑说说自己的理解吧，断点，顾名思义就是从前有一个点，后来它断了，谢谢，我的故事讲完了。哎哟还不服，这些基础常识的东西自己不会查？你还真的脸皮厚上天了去了，还要博主给你查哟，自己查去！&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;普通操作&lt;/h3&gt;

&lt;p&gt;如图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基本的断点操作如下&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic4.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击那个黑列列就创建了一个断点，再次点击就临时取消这个断点(但是不删除)，长按那个断点拖出去就删除了(mac os的系统工程师就是稀饭拖动的快感)，当然也可以右键那个创建的断点，会弹出相应地菜单。&lt;/p&gt;

&lt;p&gt;当然也还可以监视某个变量！&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在对象视图中，右键某个对象，点击“Watch ‘XXX’”就完成XXX对象的监视了。&lt;/p&gt;

&lt;p&gt;这里我监视了lab这个UILabel的变量，每当这个变量进行更新它的信息就会被打印到控制台。&lt;/p&gt;

&lt;p&gt;好吧！我们最基本的创建断点的工作已经学会了，Xcode舒服在什么地方呢？就是不分Debug模式和Run模式的，可以说是无缝切换的，你只要没有创建断点，那么就是Run的正常模式，如果创建了断点并且运行到断点处，就自动进入Debug模式咯，不像某EC开头的IDE，控制面板就像开飞机的一样，几万个按钮以为很强大，其实只用了Run和Stop，还有什么Debug模式，App模式……，果然Xcode的优越感在对比中更加强烈了，舒服到极点呀，就像夏天的海风拂过菊花，嗯是的 就是那种感觉！&lt;/p&gt;

&lt;p&gt;我们创建好了断点，运行到断点就自动停下来了，像这样：&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些Debug的最基本操作技能是每一个入门的iOS开发者都要掌握的，应该当成一种本能，就像狗爱吃翔一样(噢 对不起 博主不是歧视狗的意思，博主也养过狗，很二逼但是从不吃翔！真的据我所知它从来不吃翔的，这里只是比喻只是比喻)。&lt;/p&gt;

&lt;h3 id=&quot;global-breakpoint&quot;&gt;全局断点（Global BreakPoint）&lt;/h3&gt;

&lt;p&gt;有时候在程序出错的时候不能能准确定位到奔溃的那一行代码,而是直接跑到main循环或者Appdelegate里面， 或者会给你这样的提示：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EXEC_BAD_ACCESS：&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;是不是有种想哭的冲动？尼玛~至少给我一些堆栈信息也好呀~……这个时候你千万不要砸鼠标和键盘哦，一切都是主机在运行，你砸鼠标和键盘有什么用呢？应该是踢主机呀~~，现在有了全局断点，娘亲再也不担心你砸鼠标了，你只需要这样：&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Debug导航面板进行上图的操作，你就建立了全局断点，这样只要遇到错误，debug程序就会自动定位到栈底的信息，也就是你最先出错的代码的那一行，这样你就可以快乐的debug拉~~&lt;/p&gt;

&lt;h3 id=&quot;condational-breakpoints&quot;&gt;条件断点(Condational Breakpoints)&lt;/h3&gt;

&lt;p&gt;从前有一个游戏，叫做撸啊撸，有些玩家他们知道怎么操作，会放技能会走路，但是他们不知道买装备，玩了一局下来，鞋子小刀都没有买。我为什么讲这个故事呢？因为很多小朋友学东西和玩游戏一样，看完前面的几种调试技能，就以为自己已经屌爆无敌了，其实他们不过是出门不带装备的玩家，如果只是使用了以上的调试技能只能说是低玩，在高大的逼优鸡面前根本就是会被瞬秒的那种，所以学会装备自己才是王道！条件断点，就是学会有的放矢！&lt;/p&gt;

&lt;p&gt;我们来看一段代码&lt;/p&gt;

&lt;p&gt;图8&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你是不是想问博主为何那么风骚，竟然上了Swift了！！我此刻只想吟一首湿：别人笑我太淫荡，我家住在黄鹤楼。&lt;/p&gt;

&lt;p&gt;反正这个年代大家都是吃饱了撑着的，博主也是，所以就学学Swift咯。&lt;/p&gt;

&lt;p&gt;我们如果在一个循环里面使用了断点，如果这个循环执行了100万次，那你的断点要执行那么多次，你不觉得蛋蛋都凉了的忧伤么？所以我们这么做：&lt;/p&gt;

&lt;p&gt;图9&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样只有遍历到c==“H”的时候 断点才会被触发。&lt;/p&gt;

&lt;p&gt;图10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是很棒呢！&lt;/p&gt;

&lt;p&gt;有些童鞋的钛合金狗眼已经看到了编辑断点那里有一个Action的东西，那是什么呢？&lt;/p&gt;

&lt;p&gt;这个是非常强大的，可以在你断点的位置，执行各种操作，比如执行脚本命令，控制台命令(可以制定调试信息自定义保存)、打印信息等，&lt;/p&gt;

&lt;p&gt;博主最喜欢的就是这个Log message啦，简单粗暴！根本就不需要print啊NSLog嘛，直接在断点的Action打印就好了（其实这个是Xcode和调试器结合的高能产物，下面再介绍）。具体可以这样：&lt;/p&gt;

&lt;p&gt;图11&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其实刚刚博主撒谎了，博主最喜欢的Action并不是Log Message，而是Sound，顾名思义嘛，断点射在Bug上，这样遇到断点就会发出声音，听到我自己设置的声音，我就知道是什么Bug了，听声识Bug，呵呵，&lt;code class=&quot;highlighter-rouge&quot;&gt;EXEC_BAD_ACCESS&lt;/code&gt;的错误我设置成了波多野老师的声音，&lt;code class=&quot;highlighter-rouge&quot;&gt;unrecognized selector send to instancd&lt;/code&gt;的错误我设置成了苍老师的…… 不要问我系统怎么没有吉泽明步的声音，我根本就不知道谁是吉泽明步。&lt;/p&gt;

&lt;p&gt;当然还有更加强大的条件断点就是这货啦&lt;/p&gt;

&lt;p&gt;图12&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;添加之后在 Symbol 一栏输入&lt;code class=&quot;highlighter-rouge&quot;&gt; viewDidLoad&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样一来，在程序中所有的 viewDidLoad 方法被调用时都会触发断点。&lt;/p&gt;

&lt;p&gt;图13&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，我们也可以仅仅为特定的某个类的方法添加断点。在 Symbol 一栏输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ClassName viewDidLoad] (Objective-C) &lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClassName.viewDidLoad&lt;/code&gt; (Swift) 即可。&lt;/p&gt;

&lt;p&gt;比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;unrecognized selector sent to instance 0xaxxxx&lt;/code&gt; 这种错误，这个instance可以这样快速定位&lt;/p&gt;

&lt;p&gt;图14&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;打印的艺术&lt;/h2&gt;

&lt;p&gt;尽管ARC已经让内存管理变得简单、省时和高效，但是在object的life-cycles中跟踪一些重要事件依然十分重要。毕竟ARC并没有完全排除内存泄露的可能性，或者试图访问一个被release的对象。为了这个目的，我们可以很艺术地偷窥对象正在做些什么，想想就好有快感。&lt;/p&gt;

&lt;h3 id=&quot;nslog&quot;&gt;NSLog&lt;/h3&gt;

&lt;p&gt;小伙伴们第一节课学习ViewController的生命周期的时候，老师肯定很猥琐的教了大家，在viewController的每个生命周期的方法中使用了NSLog来偷窥！没错，这样其实就是最简单爆炸的跟踪生命周期的方法了，不过系统自己的NSLog真心有点羸弱，输出的信息太少，根本就不能满足我们的欲望，这里我教大家强化你的Log！！&lt;/p&gt;

&lt;p&gt;可以用下面的这段宏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//A better version of NSLog

define NSLog(format, ...) do { \

fprintf(stderr, &quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;, \

[[[NSString stringWithUTF8String:FILE] lastPathComponent] UTF8String], \

LINE, func); \

(NSLog)((format), ##VA_ARGS); \

fprintf(stderr, &quot;-------\n&quot;); \

} while (0)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于宏的威力 大家可以乱入我的博文&lt;a href=&quot;http://daiweilai.github.io/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/&quot; target=&quot;_blank&quot;&gt;《 iOS中的预编译指令的初步探究》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这样打印出来的东西才像话嘛(其实NSLog的打印是非常低效的，甚至比print低100倍，感兴趣自己翻翻苹果手册咯)。&lt;/p&gt;

&lt;p&gt;使用objc语言(强类型)并且用NSLog打印的时候，常常搞不清楚NSLog(@“%?”,xxx) xxx这种类型该是什么什么类型输出，应该是%d呢还是%@亦或是%f？？？傻傻分不清楚~，所以玩转NSLog你应该要知道以下这几个全局方法！&lt;/p&gt;

&lt;p&gt;图17&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;enable-nszombie-objects&quot;&gt;开启僵尸对象(Enable NSZombie Objects)&lt;/h3&gt;

&lt;p&gt;Xcode可以把那些已经release掉得对象，变成“僵尸”，当我们访问一个Zombie对象时，Xcode可以告诉我们正在访问的对象是一个不应该存在的对象了。因为Xcode知道这个对象是什么，所以可以让我们知道这个对象在哪里，以及这是什么时候发生的。&lt;/p&gt;

&lt;p&gt;所以Zombies是你的好基友！他可以让你输出的信息更具体！！&lt;/p&gt;

&lt;p&gt;具体这样做：&lt;/p&gt;

&lt;p&gt;图15&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自己再试试输出Object的信息咯，是不是很棒呢？&lt;/p&gt;

&lt;p&gt;僵尸只能用在模拟器和OC语言哦~&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;进击的码农&lt;/h2&gt;

&lt;p&gt;如果说你已经把打印的艺术运用的风生水起了，并且断点的使用可以信手拈来随心所欲，那么你已经在与逼优鸡的对峙中，稳操大部分胜券了，你已经是一个孤高冷艳的程序员了，俯视一切低能的逼优鸡了！但是！面对更强大的敌人——你那秃顶1000°近视牙齿夹着韭菜的有着十年对战逼优鸡的同事面前、以及笑里藏刀眼睛有眼屎但是能用眼神杀死你的面试官…… 对于他们，你还是太弱，你的技能的磨练还太少！所以你必须要进击！！比逼优鸡还要强大的敌人出现了！我们需要更强大的武器。&lt;/p&gt;

&lt;h3 id=&quot;consolelldb-&quot;&gt;Console(lldb 命令)&lt;/h3&gt;

&lt;p&gt;我们的目标是要武装到鼻毛！console窗口大家知道就是哪个黑乎乎好多字会滚出来，尤其是被逼优鸡干到的时候，那么同学们有没有遇到这种console呢&lt;/p&gt;

&lt;p&gt;图16&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们家的编译器历史 敬请乱入 《iOS中的预编译指令的初步探究》 ，没错我们现在正在使用着世界上最好的c、c++、oc、swift的编译器——LLVM,lldb就是这个世界上最好的LLVM的调试器！不要害羞，因为我们是最优秀的！所以肯定要用最好的！千万别客气哟，随便用，就像自己家一样啊，啊 哈哈 吃吃吃 别只顾着吃饭，多夹菜……哎~博主好客的职业病又犯了~，什么？你不知道在哪里用lldb？&lt;/p&gt;

&lt;p&gt;首先！你得先crash或者把程序断下来！直到你看到图16的(lldb)字样出现，你就可以敲命令了~~&lt;/p&gt;

&lt;p&gt;每次你想查看变量，常量，你要重新写NSLog去打印，然后重新编译，去执行，重头开始？太累了，有了lldb你只要这样&lt;/p&gt;

&lt;p&gt;图18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是方便到爆炸？&lt;/p&gt;

&lt;p&gt;当你有一个switch语句，你为了测试每一个case，你都要制造假条件去测试；有一个if…else…语句，你为了测试不同的情况，你要硬编码写了不同的情况，编译好几次为了测试每种情况……，我想你应该知道为什么自己的头发那么稀疏了。&lt;/p&gt;

&lt;p&gt;以上的这些情况，只需一次编译，使用lldb的thread命令，伪造返回值，欺骗寄存器，就可以随心所欲的做完所有测试了。&lt;/p&gt;

&lt;p&gt;是不是牛逼到爆炸？&lt;/p&gt;

&lt;p&gt;lldb真的很强大，博主没有骗你，这篇博文到此的所有调试技巧lldb都可以实现，各种断点，各种打印，调用python插件，运行中断，操作硬件底层，控制程序运行线程……lldb都可以做到！仿佛lldb就是另一个强大的世界！！！&lt;/p&gt;

&lt;p&gt;是不是强大到爆炸？&lt;/p&gt;

&lt;p&gt;其实如果你不想贪多嚼不烂的话，你只要精通这个调试工具，基本前面的调试技能你可以不用学了，在这里博主也是不才，lldb的强大不是博主随便说几句就可以表达的出来的，&lt;/p&gt;

&lt;p&gt;更多地需要大家事必躬亲，才能真正体会到那种美好，那种畅快无比的调试体验！&lt;/p&gt;

&lt;p&gt;这里博主无私地掏出任意门，这里有很好的文章！可以让你好好的回味，呵呵&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lldb.llvm.org/tutorial.html&quot; target=&quot;_blank&quot;&gt;《The LLDB Debugger》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html&quot; target=&quot;_blank&quot;&gt;《About LLDB and Xcode》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/&quot; target=&quot;_blank&quot;&gt;《LLDB调试命令初探》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://objccn.io/issue-19-2/&quot; target=&quot;_blank&quot;&gt;《与调试器共舞 - LLDB 的华尔兹》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;profileinstruments&quot;&gt;Profile(instruments)&lt;/h3&gt;

&lt;p&gt;图19&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个东西怎么翻译呢？我们就叫检查器吧！！也许已经学习了iOS开发大半年的你，从来都没注意到或者使用这个工具，但是博主很负责任的告诉你现在市面上任何一款出色的APP都会使用instruments来让代码更加健壮！难道instrument是春药？怎么会使代码健壮呢？&lt;/p&gt;

&lt;p&gt;这个健壮不是那个健壮~哎~~ 我才18岁能不能清纯一点呀&lt;/p&gt;

&lt;p&gt;instrument里面包含了很多工具，内存溢出分析，性能分析，各种分析…… 如果细说的话，这个真的可以为每个工具开一篇博客，但是博主是一个懂得授人以鱼不如授人以渔的道理的老司机！所以博主当然不会全部说一遍！我们就来领着大家看看专用debug的内存溢出分析工具的使用吧！&lt;/p&gt;

&lt;p&gt;图20&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在使用leaks之前大家可以试试这个“Analyze”&lt;/p&gt;

&lt;p&gt;图21&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;analyze可以快速的发现你的代码中release的问题，以及继承过程中的父类方法缺失等等问题！一般一个优秀的iOS开发工程师No Warning、Pass Analyze是最基本的操守！我知道你已经对于你自己的项目的上百个warning已经麻木了，但博主我负责人地告诉你，这样不好！，因为有一首云南民歌《老司机带带我》听得博主神清气爽！&lt;/p&gt;

&lt;p&gt;坚守作为iOS开发者的贞操！跟着我高喊口号！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;No Warning！Pass Analyze！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们继续回来使用leaks！如果analyze都通过了，那么就可以使用leaks工具，发现千年老妖级别的侧漏了！&lt;/p&gt;

&lt;p&gt;图22&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果提示某一个对象有侧漏的风险，你还可以这样弹出侧边的拓展细节&lt;/p&gt;

&lt;p&gt;图23&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接点击方法就可以直接进入代码部分了！！&lt;/p&gt;

&lt;p&gt;是不是很简单粗暴呢！当然还很多其他工具，不过叫做篇幅的东西总是限制人，诶 真蛋疼~真的还想多说点的&lt;/p&gt;

&lt;p&gt;想要更多了解instrument 大家可以看看这篇文章！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode&quot; target=&quot;_blank&quot;&gt;《How to Use Instruments in Xcode》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;xcode&quot;&gt;Xcode视图调试&lt;/h3&gt;

&lt;p&gt;有时候有些逼优鸡隐藏的比较深，代码几乎都翻了个遍，还是没找到问题出在哪，博主可以理解那种风中凌乱，蛋碎一地的赶脚，因为无数个日夜博主就是深陷当中无法自拔，后来干脆直接重新新建一个工程！还是不行！！我去，直到有一天博主早上起来，看到镜子中自己帅气的脸庞，我才突然顿悟，原来长得帅可以那样快速的找到bug！最终锁定是可爱又可恨的xib和storyboard出了问题！！某个constraint或者view的嵌套逻辑又或者团队协作Git冲突等等问题，导致io -v什么的错误，这种情况去检查视图文件，可能xcode崩溃打不开那个xib或者storyboard，你直接使用文本工具打开这个xml类型的标记文件，你差点吐血，几万行的记录狗眼都看瞎了……。&lt;/p&gt;

&lt;p&gt;但是这个历史要被终结！！因为我们强大的xcode的视图调试功能！！&lt;/p&gt;

&lt;p&gt;以下内容，完全copy，如有不适，坚持看完！请叫我快乐的搬运工！&lt;/p&gt;

&lt;p&gt;抄袭自&lt;a href=&quot;http://code.tutsplus.com/tutorials/view-debugging-in-xcode-6--cms-22530&quot; target=&quot;_blank&quot;&gt;《View Debugging in Xcode 6》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;苹果在Xcode 6中做了不少明显的改善和优化，视图调试就是其中之一。通常，App用户界面的行为不会符合开发者期望的那样，比如或者不展示视图，或者没有正确地展示。本文讲解如何使用Xcode的新的视图调试功能来简化开发者对问题界面的确认和修复。&lt;/p&gt;

&lt;p&gt;1.Demo 工程&lt;/p&gt;

&lt;p&gt;开始之初先从github（https://github.com/tutsplus/ViewDebugging）上下载示例工程并打开ViewDebugging.xcodeproj。该工程包含一个简单的包含少数视图控制器的可点击的应用程序、应用程序委托以及一个storyboard。该app是为iPhone而设计，但受益于iOS 8的自适应布局,所以界面展示在任何设备上都没有问题。&lt;/p&gt;

&lt;p&gt;您刚刚下载的应用程序示例工程是一个简单的to-do list应用程序，包含可查看其他信息的简单屏幕，比如该示例工程中的项目数，用户头像以及@***的推特操作。点击Xcode左上角的运行按钮将展示在iOS模拟器中运行的应用程序。&lt;/p&gt;

&lt;p&gt;图24&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很快会注意到用户界面中存在问题-表视图中没有展示任何数据。在工程导航面板中打开&lt;code class=&quot;highlighter-rouge&quot;&gt;FirstViewController.swift&lt;/code&gt;并找到以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mockNotesDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Do some laundry&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Finish homework&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Walk the dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Learn about view debugging&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;didSet&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reloadData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;mockNotesDataSource&lt;/code&gt;变量是表视图的数据源。使用Swift的属性观察者功能，在数据源发生改变时，表视图会自动重新加载。通过查看以上代码片段，你会发现应该应用中应该有4个项目需要展示，但现在不展示数据就说明某些地方出现了差错。&lt;/p&gt;

&lt;p&gt;启用视图调试&lt;/p&gt;

&lt;p&gt;问题似乎与用户界面有关。运行app过程中，按下底部的Debug View Hierarchy 按钮，或者从菜单中选择Debug &amp;gt; View Debugging &amp;gt; Capture View Hierarchy 来启动视图调试。&lt;/p&gt;

&lt;p&gt;图25&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动视图调试后，Xcode会对应用程序的视图层次拍一个快照并展示三维原型视图来探究用户界面的层级。该三维视图除了展示app的视图层次外，还展示每个视图的位置、顺序和视图尺寸，以及视图间的交互方式。&lt;/p&gt;

&lt;p&gt;示例工程在Xcode中的三维视图展示正常，但表视图单元格似乎有点太宽了。&lt;/p&gt;

&lt;p&gt;图26&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;暂停应用程序调试并在左侧选中Main.Storyboard来修复问题。点击表视图并选中Editor &amp;gt; Resolve Auto Layout Issues &amp;gt; Reset to Suggested Constraints.&lt;/p&gt;

&lt;p&gt;图27&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译并再次运行应用程序以确定用户界面展示正常。点击Debug View Hierarchy按钮更进一步了解视图调试的功能。&lt;/p&gt;

&lt;p&gt;视图调试功能&lt;/p&gt;

&lt;p&gt;点击并拖拽三维渲染图的任意一边，可旋转或者倾斜用户界面，向左或者向右倾斜可选中某个表视图。&lt;/p&gt;

&lt;p&gt;选中后，Xcode会高亮该视图，并在会在右边展示Object 和Size检查器。查看在跳转栏顶部并确认UITableView是右边最后一个项目。&lt;/p&gt;

&lt;p&gt;图28&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Object 和 Size检查器包括大量有用的信息。过去开发者需要依赖日志语句或者断点来检查视图的配置。&lt;/p&gt;

&lt;p&gt;打开右边的Size inspector（规格检查器），下方是Auto Layout，可以看到视图上已经应用了正确的约束。在Object inspector中，我们可以检查所选视图的属性。&lt;/p&gt;

&lt;p&gt;图29&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Xcode的调试区有9个视图调试过程中要用到的按钮和滑块儿。&lt;/p&gt;

&lt;p&gt;图30&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从左到右控件排序：&lt;/p&gt;

&lt;p&gt;调整视图间距：调整不同视图间的间距。&lt;/p&gt;

&lt;p&gt;展示被剪切的内容：当前展示视图中被剪切的部分。&lt;/p&gt;

&lt;p&gt;展示约束：展示选中视图的约束。&lt;/p&gt;

&lt;p&gt;重置查看区域：将3D渲染透视图恢复至默认状态。&lt;/p&gt;

&lt;p&gt;调整查看模式：选择性地展示3D渲染透视图，比如仅展示内容，仅展示框架以及同时展示内容和框架。&lt;/p&gt;

&lt;p&gt;缩小：缩小3D渲染透视图&lt;/p&gt;

&lt;p&gt;恢复：将3D渲染透视图恢复至默认尺寸。&lt;/p&gt;

&lt;p&gt;放大：放大3D渲染透视图&lt;/p&gt;

&lt;p&gt;调整可视视图范围：隐藏视图或展示视图，一步步解析3D渲染视图，向左或者向右滑动滑块儿有相反的效果。&lt;/p&gt;

&lt;p&gt;建议花一点时间上手操作下这些空间，并理解各自的用处。&lt;/p&gt;

&lt;p&gt;视图层排序&lt;/p&gt;

&lt;p&gt;再次编译和运行应用程序，并点击用户界面底部的”More”标签。第一眼看去界面看起来还OK，但是它没有按照开发者的定义准确执行，图片上的模糊效果没有展示出来。我们可以通过调试视图层次来更好地确定问题所在。&lt;/p&gt;

&lt;p&gt;向左或者向右拖拽视图来查看具体情况，接着将view spacing slider向右拖动。&lt;/p&gt;

&lt;p&gt;图31&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样一来，不同视图间的间距变大了，层次也更加清晰，我们看到在图片”下方”还隐藏着另一个视图，选中隐藏的视图，它就是”丢失”的视觉效果视图。&lt;/p&gt;

&lt;p&gt;图32&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开Main.storyboard 并选中Second View Controller Scene。在左侧的文档概览面板中，展开Second View Controller的视图对象以查看子视图的排序。&lt;/p&gt;

&lt;p&gt;Xcode在文档概览中按照递升顺序堆叠视图，换句话说，列表顶层的视图是视图层次的基础。&lt;/p&gt;

&lt;p&gt;修复问题很简单。运行时，Blur Effect View隐藏在Sky Image之下，因为它是视图层次的第一个视图。在文档概览中点击并拖拽 Blur Effect View，结果会如下图展示一样：&lt;/p&gt;

&lt;p&gt;图33&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次运行应用程序就能看到模糊效果了。应用程序的用户界面看起来符合设计的初衷。我们还可以查看iOS模拟器的其他调试功能，看看还完善了其他什么地方或功能。&lt;/p&gt;

&lt;p&gt;5.iOS模拟器调试功能&lt;/p&gt;

&lt;p&gt;编译并运行应用程序，选中模拟器，从 Debug菜单中选择Color Blended Layers选项。&lt;/p&gt;

&lt;p&gt;图34&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后会看到app的用户界面被红色和绿色覆盖，显示了哪些图层可以被叠加覆盖，以及哪些图层是透明的。混合层属于计算密集型视图，所以推荐尽可能地使用不透明的图层。&lt;/p&gt;

&lt;p&gt;图35&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic35.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;苹果在其文档（iOS Simulator User Guide）中对此进行了注明，并在表视图处理上使用了不透明图层。滚动视图时会有些表现不大好的地方，一个重要的原因就是使用了混合图层，而如果内容背景是不透明层，那么页面滚动效果就会非常流畅和平稳。&lt;/p&gt;

&lt;p&gt;对于这款应用程序来说，假使用户有数百个项目要展示，可能会出现滚动性能不一致的情况。表视图单元格当前使用的是混合层。由于视图控制器的视图背景是白色，所以不管表视图单元格使用的是混合层或者不透明层，终端用户不会觉察到有什么不一样。&lt;/p&gt;

&lt;p&gt;打开Main.storyboard并选中To Do list Scene中的表视图单元格属性。在属性检查器（Attributes Inspector）中，向下滚动Drawing分区并勾选Opaque。&lt;/p&gt;

&lt;p&gt;图36&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在启用Color Blended Layers的状态下编译并运行应用程序。由于表视图单元格现在使用了不透明层，所以会用绿色覆盖，以指示它们是不透明的。&lt;/p&gt;

&lt;p&gt;除了标记图层外，还有其他一些有用的功能可帮开发者在iOS模拟器中调试应用。以下是其中一些比较有用的：&lt;/p&gt;

&lt;p&gt;Toggle Slow Animations in Frontmost App: 选中模拟器，打开Debug菜单选中Toggle Slow Animations in Frontmost App，该功能可以降低app中动画的运行速度，适合调试包含复杂动画的应用程序。也可是使用快捷键Command-T来操作。&lt;/p&gt;

&lt;p&gt;Color Copied Images:该选项可以给绘制时被Core Animation复制的图片添加蓝绿色叠加层。&lt;/p&gt;

&lt;p&gt;Color Misaligned Images:如果图片边界没有与目标像素完美对齐，该功能可为图片叠加上一层品红色。如果图片使用确定的比例大小绘制，那么该功能会为图片添加一层黄色叠加。&lt;/p&gt;

&lt;p&gt;Color Off Screen Rendered:.该选项为离屏渲染内容添加一个黄色的叠加层。&lt;/p&gt;

&lt;p&gt;很多开发者会忽略接入电话时应用状态栏的设计问题，你可以通过触发通话中状态栏来简单测试。在iOS模拟器中，从Hardware菜单中选中Toggle In-Call Status Bar。&lt;/p&gt;

&lt;p&gt;想查看app如何响应事件，可按下Command-T来启用slow animations，并按下Command-Y来展示电话接入时的状态栏。倘若你的应用程序使用了导航栏，那么操作系统会为你兼顾到这一块儿。&lt;/p&gt;

&lt;p&gt;图37&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-4-13-pic37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了给视图着色外，还要记住iOS模拟器也可以调试Core Location问题。你可以在特定经纬度模拟设备，&lt;/p&gt;

&lt;p&gt;如果你的应用程序使用iCloud来管理数据，你也可以手动触发同步事件。&lt;/p&gt;

&lt;p&gt;本文中使用的demo app非常简单，使用文中提到的技术可以帮你在未来节省不少时间。视图调试可以帮你修正很多用户界面中出现的问题。&lt;/p&gt;

&lt;p&gt;除了Xcode和InterfaceBuilder之外，使用iOS模拟器的调试功能可以提升应用性能和识别开发过程中的瓶颈。苹果的人机交互指南（中文版 英文版）强调了积极响应对app的重要性，能让用户觉得应用易于使用和操作。苹果对InterfaceBuilder的提升让视图调试变得前所未有的简单。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;这篇文章博主花了3个礼拜，断断续续才写完的，当中错漏应该非常多，但是无论如何鄙人觉得应该算是配的上豪华套餐的称号了，当中iOS开发的基本、常用以及高阶的调试技能都涉及了，但是仍然有很多其他的奇门巧技没有介绍到，主要是可恶的“篇幅”限制住了博主广博的爱，但是无论如何，这篇文章大家暂且可以当做是一个调试技术的目录，因为博主在这里写的讲的很粗浅，你不应该只满足于这篇文章，你如果想要改变世界的话，你应该借着博主的这篇目录式文章深入地学习与研究！&lt;/p&gt;

&lt;p&gt;当然还有Crash的日志、测试工程、以及强大牛逼哄哄的第三方调试库等这篇博客没有涉及到，这是一个遗憾，但是我相信聪明的你会去Google一番的！&lt;/p&gt;

&lt;p&gt;还有我们与逼优鸡的故事才刚刚开始。&lt;/p&gt;

</description>
        <pubDate>Mon, 13 Apr 2015 20:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/2015/04/13/iOS%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/2015/04/13/iOS%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
        
        <category>基础整理</category>
        
        <category>debug</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>无比迅速敏捷地开发iOS超精美控件</title>
        <description>&lt;h1 id=&quot;ios&quot;&gt;无比迅速敏捷地开发iOS超精美控件&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;自从人生第一篇博客《iOS中的预编译指令的初步探究》问世以来 浏览量竟然达到了360多，（路过的大神勿笑！）这些浏览量使我兴奋异常但又令我黯然神伤，为何我会眼里常含泪水？因为国人伸手党达90%！！！区区只有可怜的三个评论，可怜的三个评论~ 没有鼓励~ 没有鲜花~ 也没有谩骂~ 但是我不哭 因为贱人会笑！我深信：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一日伸手党，bug终身随！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这次的东西标题为《无比迅速敏捷地开发iOS超精美控件》！就问你怕不怕！！本人深恶痛绝标题党丫的，所以今天我就绝对会展示一些奇淫巧技！帅气并且超快的撸出一个iOS精美控件！别说我坑你？&lt;/p&gt;

&lt;p&gt;上图1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个我叫它DDClock，所有view都使用Quartz 2D绘制，创建后自动与当前系统对时同步，漂亮、精致、优雅…… （如果你看到这里，你说不漂亮、不精致、不优雅，那么请你出去，我担心我会下手过重，呵呵），想知道怎么弄得？别急！让博主带你手拿菜刀砍电线，一路火光加闪电！！！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;设计&lt;/h2&gt;

&lt;p&gt;在工程界有一个说法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计的优秀与否，是导致这个产品成败的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好吧设计先行！想好了再动手！想好了再动手在生活中是很重要，比如小学生和初中生是怎么区分的？区别就是在LOL中他们对技能的施放是否进行周密的思考，所以一些选手一个人直接冲进人堆里，技能啪啪一甩，然后就挂了——小学生！所以嘛，做事情前养成思考的习惯，是脱离小学生群体的重要手段哦~&lt;/p&gt;

&lt;p&gt;前面说到一点，DDClock创建后需要自动与当前系统对时同步；所以&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们不妨让DDClock继承UIView，然后重载&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/code&gt;方法，在这个方法中帅气的画出那个时钟所有细节！我们的决心是坚决不使用人民的一张图片！；&lt;/li&gt;
  &lt;li&gt;然后分析整个DDClock只有指针（时分秒针）和指示上下午的AM、PM会动！所以我们要把这些个东西射成变量！关于指针的运动，我们可以使用定时器，每秒都和系统对时；&lt;/li&gt;
  &lt;li&gt;我们还要支持主题的切换，那就给DDClock定义一个枚举咯；&lt;/li&gt;
  &lt;li&gt;然后就这样…&lt;/li&gt;
  &lt;li&gt;然后就这样这样……&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;哈~ 在我们精细的设计中，这个DDClock的产品形态竟然出乎的饱满，俗话说的好，打铁要趁热，豆腐趁热吃。我们马上祭出杀器XCode！！我知道你现在已经兴奋了&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;编码&lt;/h2&gt;

&lt;p&gt;我们就新建一个项目 叫做DDClockDemo吧，用来测试待会我们设计的DDClock。&lt;/p&gt;

&lt;p&gt;然后我们就在项目中新建一个Group（文件夹）吧 ，就命名成DDClock嘛~&lt;/p&gt;

&lt;p&gt;再然后嘛，我们就在DDClock的文件夹下新建一个OC对象吧（Cocoa Touch Class）取名字DDClock，让它继承UIView&lt;/p&gt;

&lt;p&gt;Nice！！来看看我们的工程目录结构 图2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好！我们要开始写代码咯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//
//  DDClock.h
//  Created by David on 15/1/26.
//  博客：http://daiweilai.github.io
//  github：https://github.com/daiweilai/
//  Copyright (c) 2015年 DavidDay. All rights reserved.
// 

#import &amp;lt;UIKit/UIKit.h&amp;gt;
#define DDClockSize 200 //默认时钟的长宽都为200
#if ! __has_feature(objc_arc)
#error &quot;需要开启ARC&quot;
#endif

@protocol DDLockDelegate 
@optional
-(UIColor*)rimColor;
-(UIColor*)markColor;
-(UIColor*)faceColor;
-(UIColor*)fontColor;
-(UIColor*)secondHandColor;
-(UIColor*)hourAndMinuteHandColor;
@end


@interface DDClock : UIView
@property (weak, nonatomic) id delegate;
typedef NS_ENUM(NSUInteger, DDClockTheme) { //弄一个枚举类型用来更改主题
    DDClockThemeDefault = 0,
    DDClockThemeDark,
    DDClockThemeModerm
};
//DDClock的构造方法 delegate:代理
-(instancetype)initWithDelegate:(id)delegate frame:(CGRect)frame;
///DDClock的构造方法 theme:主题 
-(instancetype)initWithTheme:(DDClockTheme)theme frame:(CGRect)frame;
@end

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//
//  DDClock.m
//  Created by David on 15/1/26.
//  博客：http://daiweilai.github.io
//  github：https://github.com/daiweilai/
//  Copyright (c) 2015年 DavidDay. All rights reserved.
//

#import &quot;DDClock.h&quot;

@interface DDClock(){
    //// 声明颜色
    UIColor* rimColor;
    UIColor* faceColor;
    UIColor* markColor;
    UIColor* secondHandColor;
    UIColor* fontColor;
    UIColor* hourAndMinuteHandColor;
    DDClockTheme _theme;
    float _scale;
    CGPoint _centerPoint;
}
@end


@implementation DDClock


-(instancetype)initWithDelegate:(id)delegate frame:(CGRect)frame{
    //防止用户在构建的时候传入的height和widt不一样 因为时钟是圆的所以强制把他们变成长宽一样
    CGFloat size = frame.size.height&amp;gt;frame.size.width?frame.size.height:frame.size.width;
    CGRect realRect = CGRectMake(frame.origin.x, frame.origin.y, size, size);
    self = [self initWithFrame:realRect];
    if (self) {
        _scale = realRect.size.height / DDClockSize; //放大缩小的比例系数
        _centerPoint = CGPointMake(size/2, size/2); //中心点
        //先使用默认的颜色初始化 防止用户没有调用delegate方法
        rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
        faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
        markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
        secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
        fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
        hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];

		//判断用户是否使用了delegate的方法
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;rimColor&quot;)]) {
            rimColor = [delegate rimColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;faceColor&quot;)]) {
            faceColor = [delegate faceColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;markColor&quot;)]) {
            markColor = [delegate markColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;fontColor&quot;)]) {
            fontColor = [delegate fontColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;hourAndMinuteHandColor&quot;)]) {
            hourAndMinuteHandColor = [delegate hourAndMinuteHandColor];
        }
        if ([delegate respondsToSelector:NSSelectorFromString(@&quot;secondHandColor&quot;)]) {
            secondHandColor = [delegate secondHandColor];
        }
		
		//秒针使用图片画出来
        UIImage *img = [self drawSecondHandWithColor:secondHandColor scale:_scale frameSize:CGSizeMake(size, size) currentAngle:[self secondAngleFromDate:[NSDate new]]];
        UIImageView *imgV = [[UIImageView alloc] initWithImage:img];
        imgV.frame = CGRectMake(0 , 0, size, size);
        [self addSubview:imgV];

        //1.创建动画并指定动画属性
        CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];

        //2.设置动画属性初始值、结束值
        //    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];//
        basicAnimation.toValue=[NSNumber numberWithFloat:2*M_PI];

        //设置其他动画属性
        basicAnimation.duration=60.0;//60秒转一圈
        basicAnimation.autoreverses=false;//旋转后再旋转到原来的位置
        basicAnimation.repeatCount = CGFLOAT_MAX;//无限循环的执行动画

        imgV.layer.anchorPoint = CGPointMake(0.5, 0.5);//设置秒针的旋转中心 就是这个view的中心！


        //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取
        [imgV.layer addAnimation:basicAnimation forKey:@&quot;Rotation&quot;];



        //当这个DDClock被创建出来的时候，就新建一个定时器，1分钟执行一次“onTimer”方法 其实这里做是不够好的 因为这样不能确保秒针走到12的时候更新 时针和分针 要想解决也很容易 最近生病 难受 不想解决了~~
        [NSTimer scheduledTimerWithTimeInterval:60.0 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
    }
    self.backgroundColor = [UIColor clearColor];
    return self;

}


///构造方法 使用默认主题
-(instancetype)initWithTheme:(DDClockTheme)theme frame:(CGRect)frame{
    //防止用户在构建的时候传入的height和widt不一样 因为时钟是圆的所以强制把他们变成一样
    CGFloat size = frame.size.height&amp;gt;frame.size.width?frame.size.height:frame.size.width;
    CGRect realRect = CGRectMake(frame.origin.x, frame.origin.y, size, size);
    self = [self initWithFrame:realRect];
    if (self) {
        _theme = theme;
        _scale = realRect.size.height / DDClockSize;
        _centerPoint = CGPointMake(size/2, size/2);

        switch (theme) { //根据主题绘制不同的颜色
            case DDClockThemeDefault:
                rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                break;

            case DDClockThemeDark:
                rimColor = [UIColor colorWithRed: 66.0/255 green: 66.0/255 blue: 66.0/255 alpha: 1];
                faceColor = [UIColor colorWithRed: 66.0/255 green: 66.0/255 blue: 66.0/255 alpha: 1];
                markColor = [UIColor colorWithRed:  1 green: 1 blue: 1 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 32.0/255.0 green: 250.0/255.0 blue: 200.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                break;

            case DDClockThemeModerm:
                rimColor = [UIColor colorWithRed: 60.0/255 green: 90.0/255 blue: 110.0/255 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 210.0/255.0 green: 0 blue: 10.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 210.0/255.0 green: 0 blue: 10.0/255.0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 60.0/255 green: 90.0/255 blue: 110.0/255 alpha: 1];
                break;
            default:
                rimColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                faceColor = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
                markColor = [UIColor colorWithRed:  160.0/255.0 green: 160.0/255.0 blue: 160.0/255.0 alpha: 1];
                secondHandColor = [UIColor colorWithRed: 86.0/255.0 green: 232.0/255.0 blue: 157.0/255.0 alpha: 1];
                fontColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                hourAndMinuteHandColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
                break;
        }

        if ([_delegate rimColor]) {
            rimColor = [_delegate rimColor];
        }
        if ([_delegate faceColor]) {
           faceColor = [_delegate faceColor];
        }
        if ([_delegate markColor]) {
            markColor = [_delegate markColor];
        }
        if ([_delegate fontColor]) {
            fontColor = [_delegate fontColor];
        }
        if ([_delegate faceColor]) {
            faceColor = [_delegate faceColor];
        }
        if ([_delegate hourAndMinuteHandColor]) {
            hourAndMinuteHandColor = [_delegate hourAndMinuteHandColor];
        }
        if ([_delegate secondHandColor]) {
            secondHandColor = [_delegate secondHandColor];
        }



        UIImage *img = [self drawSecondHandWithColor:secondHandColor scale:_scale frameSize:CGSizeMake(size, size) currentAngle:[self secondAngleFromDate:[NSDate new]]];
        UIImageView *imgV = [[UIImageView alloc] initWithImage:img];
        imgV.frame = CGRectMake(0 , 0, size, size);
        [self addSubview:imgV];

        //1.创建动画并指定动画属性
        CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];

        //2.设置动画属性初始值、结束值
        //    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];
        basicAnimation.toValue=[NSNumber numberWithFloat:2*M_PI];

        //设置其他动画属性
        basicAnimation.duration=60.0;
        basicAnimation.autoreverses=false;//旋转后再旋转到原来的位置
        basicAnimation.repeatCount = CGFLOAT_MAX;

        imgV.layer.anchorPoint = CGPointMake(0.5, 0.5);


        //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取
        [imgV.layer addAnimation:basicAnimation forKey:@&quot;Rotation&quot;];



        //当这个View被创建出来的时候，就新建一个定时器，1分钟执行一次“onTimer”方法
        [NSTimer scheduledTimerWithTimeInterval:60.0 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
    }
    self.backgroundColor = [UIColor clearColor];
    return self;
}

//每秒钟刷新视图一次
-(void)onTimer{
    dispatch_async(dispatch_get_main_queue(), ^{
        [self setNeedsDisplay];//这个方法调用后就会刷新这个View
    });
}

//View刷新这个方法就被调用，就会重新画出这个View
-(void)drawRect:(CGRect)rect{
    [super drawRect:rect];
    //获取当前的时间进行View的绘制
    [self drawDDClockWithScale:_scale centerPoint:_centerPoint currentDate:[NSDate new]];


}

////画出秒针
-(UIImage*)drawSecondHandWithColor:(UIColor*)color scale:(CGFloat)scale frameSize:(CGSize)size currentAngle:(float)currentAngle{
    UIGraphicsBeginImageContext(size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    //// secondHand Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, size.height/2, size.height/2);
    CGContextRotateCTM(context, (currentAngle - 90) * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* secondHandPath = UIBezierPath.bezierPath;
    [secondHandPath moveToPoint: CGPointMake(4.96, -4.87)];
    [secondHandPath addCurveToPoint: CGPointMake(6.93, -0.92) controlPoint1: CGPointMake(6.07, -3.76) controlPoint2: CGPointMake(6.73, -2.37)];
    [secondHandPath addLineToPoint: CGPointMake(66.01, -0.92)];
    [secondHandPath addLineToPoint: CGPointMake(66.01, 0.08)];
    [secondHandPath addLineToPoint: CGPointMake(7.01, 0.08)];
    [secondHandPath addCurveToPoint: CGPointMake(4.96, 5.03) controlPoint1: CGPointMake(7.01, 1.87) controlPoint2: CGPointMake(6.32, 3.66)];
    [secondHandPath addCurveToPoint: CGPointMake(-4.94, 5.03) controlPoint1: CGPointMake(2.22, 7.76) controlPoint2: CGPointMake(-2.21, 7.76)];
    [secondHandPath addCurveToPoint: CGPointMake(-4.94, -4.87) controlPoint1: CGPointMake(-7.68, 2.29) controlPoint2: CGPointMake(-7.68, -2.14)];
    [secondHandPath addCurveToPoint: CGPointMake(4.96, -4.87) controlPoint1: CGPointMake(-2.21, -7.61) controlPoint2: CGPointMake(2.22, -7.61)];
    [secondHandPath closePath];
    [color setFill];
    [secondHandPath fill];
    CGContextRestoreGState(context);
    UIImage *img = [UIImage new];
    img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return img;
}


///把当前的时间转换为时针、分针、角度
-(NSArray*)HourAndMinuteAngleFromDate:(NSDate*)date{
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;HH&quot;];//强制24小时格式
    float hourf = [[formatter stringFromDate:date] floatValue];
    [formatter setDateFormat:@&quot;mm&quot;];
    float minutef = [[formatter stringFromDate:date] floatValue];
    if (hourf &amp;gt; 12) {//大于24小时我们就减去12小时嘛 比较好算角度呀
        hourf = (hourf - 12)*30 + 30*(minutef/60); //一小时30°
    }else{
        hourf = hourf*30 + 30*(minutef/60);
    }
    minutef = minutef*6;//一分钟6°
    NSNumber *hour =  [[NSNumber alloc] initWithInt:hourf];
    NSNumber *minute = [[NSNumber alloc] initWithInt:minutef];
    NSArray *arr = [[NSArray alloc] initWithObjects:hour,minute, nil];
    return arr;
}

//因为秒针的实时性 所以单独算出当前秒针的角度
-(float)secondAngleFromDate:(NSDate*)date{
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;ss&quot;];
    float secondf = [[formatter stringFromDate:date] floatValue];
    secondf = secondf*6;//一分钟6°
    return secondf;
}

//绘制图形的主要方法
- (void)drawDDClockWithScale: (CGFloat)scale centerPoint:(CGPoint)centerPoint currentDate:(NSDate*)currentDate;
{
    NSArray *arr = [self HourAndMinuteAngleFromDate:currentDate];
    NSNumber *hourAngle = (NSNumber*)[arr objectAtIndex:0];
    NSNumber *minuteAngle = (NSNumber*)[arr objectAtIndex:1];



    //获取绘图上下文
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// 画出边框
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* rimPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-100, -100, 200, 200)];
    [rimColor setFill];
    [rimPath fill];

    CGContextRestoreGState(context);


    //// 画出钟表盘
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* facePath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-92.99, -92.92, 186, 186)];
    [faceColor setFill];
    [facePath fill];

    CGContextRestoreGState(context);


    //// 上午下午时间的判断
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect aMPMRect = CGRectMake(-15.99, -42.92, 32, 18);
    NSMutableParagraphStyle* aMPMStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    aMPMStyle.alignment = NSTextAlignmentCenter;

    NSDictionary* aMPMFontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 15], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: aMPMStyle};
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;HH&quot;];//强制24小时格式
    float hourf = [[formatter stringFromDate:currentDate] floatValue];//为了节省系统资源 延迟一分钟才会更新 因为这个方法是一分钟 调用一次的
    NSString *str = hourf&amp;lt;12?@&quot;AM&quot;:@&quot;PM&quot;;
    [str drawInRect: aMPMRect withAttributes: aMPMFontAttributes];

    CGContextRestoreGState(context);


    //// 画出时针
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextRotateCTM(context, [hourAngle floatValue] * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* hourHandPath = [UIBezierPath bezierPathWithRect: CGRectMake(-4.99, -52.46, 10, 43.54)];
    [hourAndMinuteHandColor setFill];
    [hourHandPath fill];

    CGContextRestoreGState(context);


    //// 画出分针
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextRotateCTM(context, ([minuteAngle floatValue]) * M_PI / 180);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* minuteHandPath = [UIBezierPath bezierPathWithRect: CGRectMake(-2.99, -64.92, 6, 55.92)];
    [hourAndMinuteHandColor setFill];
    [minuteHandPath fill];

    CGContextRestoreGState(context);





    //// 画出中间的圆圈
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* centreEmptyOvalPath = UIBezierPath.bezierPath;
    [centreEmptyOvalPath moveToPoint: CGPointMake(-4.42, -4.35)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-4.42, 4.33) controlPoint1: CGPointMake(-6.82, -1.95) controlPoint2: CGPointMake(-6.82, 1.93)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(4.26, 4.33) controlPoint1: CGPointMake(-2.02, 6.73) controlPoint2: CGPointMake(1.86, 6.73)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(4.26, -4.35) controlPoint1: CGPointMake(6.66, 1.93) controlPoint2: CGPointMake(6.66, -1.95)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-4.42, -4.35) controlPoint1: CGPointMake(1.86, -6.75) controlPoint2: CGPointMake(-2.02, -6.75)];
    [centreEmptyOvalPath closePath];
    [centreEmptyOvalPath moveToPoint: CGPointMake(7.78, -7.7)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(7.78, 7.85) controlPoint1: CGPointMake(12.08, -3.41) controlPoint2: CGPointMake(12.08, 3.56)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-7.77, 7.85) controlPoint1: CGPointMake(3.49, 12.15) controlPoint2: CGPointMake(-3.48, 12.15)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(-7.77, -7.7) controlPoint1: CGPointMake(-12.07, 3.56) controlPoint2: CGPointMake(-12.07, -3.41)];
    [centreEmptyOvalPath addCurveToPoint: CGPointMake(7.78, -7.7) controlPoint1: CGPointMake(-3.48, -12) controlPoint2: CGPointMake(3.49, -12)];
    [centreEmptyOvalPath closePath];
    [hourAndMinuteHandColor setFill];
    [centreEmptyOvalPath fill];

    CGContextRestoreGState(context);


    //// 画出“12”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text12Rect = CGRectMake(-10, -82, 21, 17);
    {
        NSString* textContent = @&quot;12&quot;;
        NSMutableParagraphStyle* text12Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text12Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text12FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text12Style};

        [textContent drawInRect: CGRectOffset(text12Rect, 0, (CGRectGetHeight(text12Rect) - [textContent boundingRectWithSize: text12Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text12FontAttributes context: nil].size.height) / 2) withAttributes: text12FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“3”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text3Rect = CGRectMake(72, -9, 12, 17);
    {
        NSString* textContent = @&quot;3&quot;;
        NSMutableParagraphStyle* text3Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text3Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text3FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text3Style};

        [textContent drawInRect: CGRectOffset(text3Rect, 0, (CGRectGetHeight(text3Rect) - [textContent boundingRectWithSize: text3Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text3FontAttributes context: nil].size.height) / 2) withAttributes: text3FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“6”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text6Rect = CGRectMake(-4, 65, 12, 17);
    {
        NSString* textContent = @&quot;6&quot;;
        NSMutableParagraphStyle* text6Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text6Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text6FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text6Style};

        [textContent drawInRect: CGRectOffset(text6Rect, 0, (CGRectGetHeight(text6Rect) - [textContent boundingRectWithSize: text6Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text6FontAttributes context: nil].size.height) / 2) withAttributes: text6FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出“9”
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    CGRect text9Rect = CGRectMake(-82, -8, 12, 17);
    {
        NSString* textContent = @&quot;9&quot;;
        NSMutableParagraphStyle* text9Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
        text9Style.alignment = NSTextAlignmentCenter;

        NSDictionary* text9FontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @&quot;Helvetica-Bold&quot; size: 18], NSForegroundColorAttributeName: fontColor, NSParagraphStyleAttributeName: text9Style};

        [textContent drawInRect: CGRectOffset(text9Rect, 0, (CGRectGetHeight(text9Rect) - [textContent boundingRectWithSize: text9Rect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: text9FontAttributes context: nil].size.height) / 2) withAttributes: text9FontAttributes];
    }

    CGContextRestoreGState(context);


    //// 画出表盘刻度
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, centerPoint.x, centerPoint.y);
    CGContextScaleCTM(context, scale, scale);

    UIBezierPath* markPath = UIBezierPath.bezierPath;
    [markPath moveToPoint: CGPointMake(-2, -85)];
    [markPath addLineToPoint: CGPointMake(2, -85)];
    [markPath addLineToPoint: CGPointMake(2, -93)];
    [markPath addLineToPoint: CGPointMake(-2, -93)];
    [markPath addLineToPoint: CGPointMake(-2, -85)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-1, 93)];
    [markPath addLineToPoint: CGPointMake(3, 93)];
    [markPath addLineToPoint: CGPointMake(3, 85)];
    [markPath addLineToPoint: CGPointMake(-1, 85)];
    [markPath addLineToPoint: CGPointMake(-1, 93)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-45, -72.15)];
    [markPath addLineToPoint: CGPointMake(-41.54, -74.15)];
    [markPath addLineToPoint: CGPointMake(-45.54, -81.08)];
    [markPath addLineToPoint: CGPointMake(-49, -79.08)];
    [markPath addLineToPoint: CGPointMake(-45, -72.15)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(44.87, 81.5)];
    [markPath addLineToPoint: CGPointMake(48.33, 79.5)];
    [markPath addLineToPoint: CGPointMake(44.33, 72.57)];
    [markPath addLineToPoint: CGPointMake(40.87, 74.57)];
    [markPath addLineToPoint: CGPointMake(44.87, 81.5)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-75.07, -40)];
    [markPath addLineToPoint: CGPointMake(-73.07, -43.46)];
    [markPath addLineToPoint: CGPointMake(-80, -47.46)];
    [markPath addLineToPoint: CGPointMake(-82, -44)];
    [markPath addLineToPoint: CGPointMake(-75.07, -40)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(79.58, 48.13)];
    [markPath addLineToPoint: CGPointMake(81.58, 44.67)];
    [markPath addLineToPoint: CGPointMake(74.65, 40.67)];
    [markPath addLineToPoint: CGPointMake(72.65, 44.13)];
    [markPath addLineToPoint: CGPointMake(79.58, 48.13)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-85, 2)];
    [markPath addLineToPoint: CGPointMake(-85, -2)];
    [markPath addLineToPoint: CGPointMake(-93, -2)];
    [markPath addLineToPoint: CGPointMake(-93, 2)];
    [markPath addLineToPoint: CGPointMake(-85, 2)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(93, 1)];
    [markPath addLineToPoint: CGPointMake(93, -3)];
    [markPath addLineToPoint: CGPointMake(85, -3)];
    [markPath addLineToPoint: CGPointMake(85, 1)];
    [markPath addLineToPoint: CGPointMake(93, 1)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-72.57, 44)];
    [markPath addLineToPoint: CGPointMake(-74.57, 40.54)];
    [markPath addLineToPoint: CGPointMake(-81.5, 44.54)];
    [markPath addLineToPoint: CGPointMake(-79.5, 48)];
    [markPath addLineToPoint: CGPointMake(-72.57, 44)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(81.08, -45.87)];
    [markPath addLineToPoint: CGPointMake(79.08, -49.33)];
    [markPath addLineToPoint: CGPointMake(72.15, -45.33)];
    [markPath addLineToPoint: CGPointMake(74.15, -41.87)];
    [markPath addLineToPoint: CGPointMake(81.08, -45.87)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(-39.67, 75.07)];
    [markPath addLineToPoint: CGPointMake(-43.13, 73.07)];
    [markPath addLineToPoint: CGPointMake(-47.13, 80)];
    [markPath addLineToPoint: CGPointMake(-43.67, 82)];
    [markPath addLineToPoint: CGPointMake(-39.67, 75.07)];
    [markPath closePath];
    [markPath moveToPoint: CGPointMake(48.46, -79.58)];
    [markPath addLineToPoint: CGPointMake(45, -81.58)];
    [markPath addLineToPoint: CGPointMake(41, -74.65)];
    [markPath addLineToPoint: CGPointMake(44.46, -72.65)];
    [markPath addLineToPoint: CGPointMake(48.46, -79.58)];
    [markPath closePath];
    [markColor setFill];
    [markPath fill];

    CGContextRestoreGState(context);
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xcode6.1 SDK8.1测试没问题！&lt;/p&gt;

&lt;p&gt;代码中已经有无比详细的注释，而且该控件简单地令人发指~ 我相信你看的懂得！&lt;/p&gt;

&lt;p&gt;我想肯定有同学已经排着队，准备好了板砖，鸡蛋什么的，“博主！你妹！说好的无比迅速敏捷地开发iOS超精美控件 哪里迅速哪里敏捷？说好的奇淫巧技呢？”&lt;/p&gt;

&lt;p&gt;都说心急吃不了热豆腐，我有说文章结束了么？文章只是出轨而已了……&lt;/p&gt;

&lt;h2 id=&quot;paintcode&quot;&gt;PaintCode&lt;/h2&gt;

&lt;p&gt;代码是写出来了， 但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/code&gt;方法中一笔一笔的勾画出来，确实是累人~&lt;/p&gt;

&lt;p&gt;所以我要祭出这次文章的纯24K真大杀器——PaintCode&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为何要称PaintCode为终极大杀器？因为它真的很凶！如果说我们刚刚的项目需要花2~3个小时才能完成 而有了PaintCode之后我们只需要10~20分钟！！！就问你怕不怕！！！&lt;/p&gt;

&lt;p&gt;售价$99的PaintCode用起来就是爽！&lt;/p&gt;

&lt;p&gt;我突然想起自己的一个故事，有一年上大学，父亲到车站来送我，临上车前，父亲叮嘱我等他一会儿他要过铁道对面要给我买点东西，说我一个人过日子会很艰难，我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了一个黑塑料袋子往回走了。过铁道时，他先将塑料袋散放在地上，自己慢慢爬下，再抱起塑料袋走。到这边时，我赶紧去搀他。他和我走到车上，将塑料袋一股脑儿放在我的皮大衣上：“最新的全是外国的动作片、游戏、音乐光盘，好好照顾自己”，想起老父亲微薄的退休金，我就有点气愤：“爸，你怎么……”，父亲赶忙凑到我的耳边：“D版的，八国联军当年抢得钱是该要回来的”，我：“……”&lt;/p&gt;

&lt;p&gt;好了我的故事讲完了 你们应该知道怎么找PaintCode了额&lt;/p&gt;

&lt;p&gt;我么开始PaintCode之旅吧&lt;/p&gt;

&lt;p&gt;打开Paint&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就像PS一样只要你画的出，就能生成代码（支持swift哦）&lt;/p&gt;

&lt;p&gt;我们就试试画出DDClock来吧&lt;/p&gt;

&lt;p&gt;选中Oval&lt;/p&gt;

&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按住shift键拖出一个规则的圆形 ，填充颜色，这个就是代码中的rimPath&lt;/p&gt;

&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次选中Oval，同样的方法在拖一个圆出来，&lt;/p&gt;

&lt;p&gt;图7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个就是代码中的facePath。&lt;/p&gt;

&lt;p&gt;在PaintCode中尽量将所有的图形、颜色都自己取一个名字，比如我把第一个Oval取名字rim，第二个Oval取名字face&lt;/p&gt;

&lt;p&gt;这样表盘的边框和中间都出来了额，接下来就是表盘的刻度了&lt;/p&gt;

&lt;p&gt;选中rect&lt;/p&gt;

&lt;p&gt;图8&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拖出其中的一个小刻度&lt;/p&gt;

&lt;p&gt;图9&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后选中这个小刻度复制出另一个小刻度，放到第一个刻度的对面，就像这样&lt;/p&gt;

&lt;p&gt;图10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后按住shift键 同时选中这两个小刻度，点击工具栏的Union&lt;/p&gt;

&lt;p&gt;图11&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样两个小刻度就成为了一个对象，这时点击右侧的Transforms，就会出现旋转图形的操作，把旋转中心（图12中绿色的瞄准星）拖到钟表的中心位置&lt;/p&gt;

&lt;p&gt;图12&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样设置Rotation的参数就可以围绕整个钟表旋转这个刻度了，所以马上同时复制这个刻度5份，分别操作旋转，让它们分别旋转30、60、90、120、150这样所有的刻度都出来了，然后再一次性的选中所有刻度Union一次，把所有刻度合并成一个图形。&lt;/p&gt;

&lt;p&gt;图13&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来就选中Text工具&lt;/p&gt;

&lt;p&gt;图14&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选中恰当的字体和大小，画出刻度值和上下午提示的AM/PM&lt;/p&gt;

&lt;p&gt;图15&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后是时针、分针和秒针了，做法是雷同的，聪明的你肯定知道该怎么做了，反正就是使用规则图形，通过Union、Intersection、Difference的操作产生不规则的图形&lt;/p&gt;

&lt;p&gt;图16&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图17&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-29-pic18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后看我的项目大体情况；&lt;/p&gt;

&lt;p&gt;到了这一步其实就可以直接复制代码走人就OK拉&lt;/p&gt;

&lt;p&gt;然后稍微写写项目的逻辑代码，测试，OK啦，是不是把2、3个小时的事情10分钟完成了？哈哈哈&lt;/p&gt;

&lt;p&gt;其实PaintCode的强大远不止于此，里面的Variables的功能，可以将图形中的某个值设置成变量，比如代码中的hourAngle、 minuteAngle 、 secondAngle 等，DDClock目前的大小的是固定的200x200，其实使用Variables添加scale的变量，还可以动态的修改所有图形的大小！当然还有Frame的使用啦……&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;对于PaintCode博主也只是浅尝而止，更多强大的功能，同学们还是自己挖掘吧。&lt;/p&gt;

&lt;p&gt;这里附上官网的&lt;a href=&quot;http://www.paintcodeapp.com/&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;，PaintCode 里面有视频教程，文档等（视频是油管网的，所以需要爬梯子，呵呵，你懂的）&lt;/p&gt;

&lt;p&gt;这里也附上我写的项目源代码 &lt;a href=&quot;https://github.com/daiweilai/DDClock&quot; target=&quot;_blank&quot;&gt;DDClock&lt;/a&gt;（尼玛！github使用代理比直接访问更快，你能忍？）&lt;/p&gt;

&lt;p&gt;这个礼拜，完成了毕设的主题和一些细节，大概是设计一套移动客户端和后台服务器安全交互的方案，涉及到各种安全通信，可靠性传输，内容加解密等内容，我会把这个设想写到博客上的；&lt;/p&gt;

&lt;p&gt;女朋友回老家了，剩下自己一个人撸啊撸T_T;&lt;/p&gt;

&lt;p&gt;天杀的12306买了两天都没买到回家的票，明明买不到票，却还要写着有余票，哎，最后我决定坐头等舱回家了~&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/2015/01/29/%E6%97%A0%E6%AF%94%E8%BF%85%E9%80%9F%E6%95%8F%E6%8D%B7%E5%9C%B0%E5%BC%80%E5%8F%91iOS%E8%B6%85%E7%B2%BE%E7%BE%8E%E6%8E%A7%E4%BB%B6/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/2015/01/29/%E6%97%A0%E6%AF%94%E8%BF%85%E9%80%9F%E6%95%8F%E6%8D%B7%E5%9C%B0%E5%BC%80%E5%8F%91iOS%E8%B6%85%E7%B2%BE%E7%BE%8E%E6%8E%A7%E4%BB%B6/</guid>
        
        <category>奇巧集</category>
        
        <category>PaintCode</category>
        
        
      </item>
    
      <item>
        <title>iOS中的预编译指令</title>
        <description>&lt;h1 id=&quot;ios&quot;&gt;iOS中的预编译指令的初步探究&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;开篇&lt;/h2&gt;

&lt;p&gt;我们人类创造东西的时候有个词叫做”仿生学“！人类创造什么东西都会模仿自己来创造，所以上帝没有长成树的样子而和人长得一样，科幻片里面外星人也像人一样有眼睛有鼻子……但是人类自己创造的东西如果太像自己，自己又会吓尿(恐怖谷效应)，人类真是奇葩；奇葩的我们在20世纪创造了改变世界的东西——计算机(电脑)，不用怀疑，这货当然也是仿生学！这货哪里长得像人了？？别不服，先听我说完，先把你的砖头放下。狭义的仿生学是外形上仿生嘛，其实广义上仿生学还可以原理的仿生，构造的仿生，性能的仿生阿拉巴拉……，计算机(这里我狭义的使用个人PC来举例)我们常说的有输入设备(键盘呀鼠标呀摄像头呀……)、处理设备(CPU、GPU……)和输出设备(显示器、音响……);然后你自个儿瞅瞅你自己的眼睛耳朵(输入),大脑(处理),四肢(输出) 当初设计电脑必须要这种构造的人难道不是瞅着自己来设计计算机的么？^_^&lt;/p&gt;

&lt;p&gt;所以上计算机组成原理的时候有什么地方晦涩难以理解的时候，我就立刻解禁我高中的生物知识，然后就迎刃而解了~但是今天我这篇博客是要讲程序的呀，这把犊子扯的那么远看客们也难免心有愤懑，你切勿急躁，我马上就带你们飞！跟着我用仿生学的角度去理解计算机，那么计算机程序是神马呢？教科书上怎么说？可以被计算机执行，那神马东西会被人执行的呢？老婆的命令、老爸的呵斥、项目经理的需求变更……我们都会执行，貌似这就是人的程序了，这确实就是人的程序！下面我具体拿老婆的命令来详解一下人得程序的执行过程；比如老婆说了一句”你给我滚出去睡沙发！“，首先这句话的处理流程是这样的：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;带你们看计算机程序执行过程之前，我们要严肃的了解一点程序的编译，也就是上图中的，我们把老婆的命令转换成电信号的过程。在计算机世界中有些好事者把这个玩意儿称作编译器(compiler)，什么gcc呀clang呀阿拉巴拉，说的编译器这名字逼格好高~其实说白了就是个翻译的东西，如我们人执行程序过程中，把老婆的话(也是人类的话)翻译成大脑懂的话(电波)，在计算机中就是把各种编程语言(c、c++、oc……)翻译成0101011……让计算机懂。编译器的工作原理基本上都是三段式的，可以分为前端（Frontend）、优化器（Optimizer）、后端（Backend）。前端负责解析源代码，检查语法错误，并将其翻译为抽象的语法树（Abstract Syntax Tree）。优化器对这一中间代码进行优化，试图使代码更高效。后端则负责将优化器优化后的中间代码转换为目标机器的代码，这一过程后端会最大化的利用目标机器的特殊指令，以提高代码的性能。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么要弄成这三段式的呢？我肯定不会从什么框架、结构啊优化……角度说起，因为我也不懂呀，哈哈 不过我可以讲一个过去的故事给大家，大家试想一下编译器是怎么开发出来的呀，好家伙，上网一搜LLVM编译器是C++写的，那c++的编译器呢？其实不用那么麻烦，现在把你的手借给我，让我牵着你回到上个世纪70年代，里奇正在为他新发明的C语言在写编译器呢，他在用汇编语言！汇编语言怎么编译变成二进制流呢？答案是使用01011机器码编写的编译器；所以编译器和计算机语言的进步就像这样迭代发展的，再之后是用高级语言写更高级的编译器，高级的编译器能编译更高级的计算机语言……，虽然蓝翔的挖掘机技术强，但问题还是来了，世界上计算机那么多，各种不同的架构，人还好基本架构都一样，但是计算机有Intel架构的又有ARM架构，怎么能让编程语言通过编译分别产生不同架构的执行码呢？所以这就是编译器三段式这种模型的好处了，当我们要支持多种语言时，只需要添加多个前端就可以了。当需要支持多种目标机器时，只需要添加多个后端就可以了。对于中间的优化器，我们可以使用通用的中间代码。gcc可以支持c、c++、java……等语言的编译。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么一个HelloWord的程序的编译和执行过程大家就按照图1自行脑补吧&lt;/p&gt;

&lt;p&gt;说了这么多终于正片开始了~ 原来我的啰嗦，因为我就是叫做话痨戴^_^，本人从没有开发过Mac os的应用所以本文主要示例代码和框架都是iOS下的，但是是因为C系语言的预编译指令，所以基本都能通用。虽然这篇文章有个宏大的开端，但是本文主要就是想探究一下编译过程中的预处理部分的部分预处理指令，希望本文能够做到的就是抛砖引玉，给比我菜的广大猿友指引一条学习的方向。&lt;/p&gt;

&lt;p&gt;在很久很久以前的Xcode不知道什么版本，Build settings里面还可以选择不同的编译器。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图4&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同的编译器，是否对于预处理指令有差异，我也没办法考究了。还有其实、其实人家接触iOS也只有3个月，我开发iOS使用的第一个IDE就是XCode6，如果坑了大家，那就索瑞~~&lt;/p&gt;

&lt;p&gt;现在Xcode6里面默认使用了Apple LLVM(Low Level Virtual Machine) 6.0的编译器&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图5&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各种编译器的区别还有几本对比知识可以参看&lt;a href=&quot;http://www.cnblogs.com/zuopeng/p/4141467.html&quot; target=&quot;_blank&quot;&gt;LLVM和GCC的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于苹果的和gcc以及LLVM背后激情个故事看以看这个&lt;a href=&quot;http://www.programmer.com.cn/9436/&quot; target=&quot;_blank&quot;&gt;三好学生Chris Lattner的LLVM编译工具链&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么接下来就是正片的高潮啦——预处理指令&lt;/p&gt;

&lt;p&gt;高潮之前再加一个预高潮^_^，干嘛要预处理呢？回去看图一，老婆说“你给我滚出去睡沙发！” 如果你没有预处理，你按照顺序运行，先滚出去了你可能还不想睡觉，你在沙发上看电视看了几个小时后才打算睡觉，这时候你发现你竟然忘了从房间拿枕头和被子出来了，你这时候就去敲老婆的门，又是一顿臭骂，之后你才能睡觉……折腾不？ 如果你进行了预处理，当老婆说完指令，其中你获取到关键字“睡沙发”，不管我滚出去之后睡不睡觉，我都先从房间把被子枕头拿到沙发，这样是不是效率高了很多？同样对于C系的语言的开发，预处理可谓举足轻重，如果你阅读过优秀的C源代码，你一定看到了很多 #define #if #error ……  预编译对程序之后的编译提供了很多方便以及优化，对于错误处理、包引用、跨平台……有着极大的帮助。而且开发中使用预编译指令完成一些事情也是很屌的事情，并且你既然走上了一条改变世界的道路那么当一个有逼格的程序猿的觉悟也需要觉醒呀&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文件包含&lt;/h2&gt;

&lt;h3 id=&quot;include&quot;&gt;#include&lt;/h3&gt;

&lt;p&gt;这个我真的不想多说，只要你大学C语言课程不是体育老师教得话，他们肯定跟你说过#include “”、#include &amp;lt;&amp;gt;的区别，他们肯定说过#include“xxx”包含和使用#include &lt;xxx&gt;包含的不同之处就是使用&amp;lt;&amp;gt;包含时，预处理器会搜索C函数库头文件路径下的文件，而使用“”包含时首先搜索程序所在目录，其次搜索系统Path定义目录，如果还是找不到才会搜索C函数库头文件所在目录。&lt;/xxx&gt;&lt;/p&gt;

&lt;p&gt;所以我不想为了弥补你老师犯下的错，我就不想重复了，有一点需要注意使用#include的时候包含文件的时候是不能递归包含的，例如a.h文件包含b.h，而b.h就不能再包含a.h了；还有就是重复包含(比如a.h包含了b.h,然后main.c中又包含了a.h和b.h)虽然是允许的但是这会降低编译性能。那该怎么办呢？1、使用#import替代include 2、使用宏判断(宏判断下面会详解)，xcode很聪明，只要新建一个头文件a.h 里面就自动就生成了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图6&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个看不懂？你可以等看完#ifndef和#define之后就明白了，大概的原理就是，用宏定义判断一个宏是否定义了，如果没有定义则会定义这个宏，这样以来如果已经包含过则这个宏定义肯定已经定义过了，即使再包含也不会重新定义了，下面的代码也就不会包含进去。&lt;/p&gt;

&lt;p&gt;这个是非C标准库里面的预处理指令，但是Xcode中允许使用，所以也就介绍一下吧。#include_next是GNU(一群牛逼的人疯狂开源的组织，可以说是Linux的灵魂)的一个扩展，并不是标准C中的指令 例如有个搜索路径链，在#include中，它们的搜索顺序依次是A，B，C，D和E。在B目录中有个头文件叫a.h，在D目录中也有个头文件叫a.h，如果在我们的源代码中这样写#include &lt;a.h&gt;，那么我们就会包含的是B目录中的a.h头文件，如果我们这样写#include_next &lt;a.h&gt;那么我们就会包含的是D目录中的a.h头文件。#include_next &lt;a.h&gt;的意思按我们上面的引号包含中的解释来说就是“在B目录中的a.h头文件后面的目录路径（即C，D和E）中搜索a.h头文件并包含进来）。#include_next &lt;a.h&gt;的操作会是这样的，它将在A，B，C，D和E目录中依次搜索a.h头文件，那么首先它会在B目录中搜索到a.h头文件，那它就会以B目录作为分割点，搜索B目录后面的目录（C，D和E），然后在这后面的目录中搜索a.h头文件，并把在这之后搜索到的a.h头文件包含进来。这样说的话大家应该清楚了吧。&lt;/a.h&gt;&lt;/a.h&gt;&lt;/a.h&gt;&lt;/a.h&gt;&lt;/p&gt;

&lt;h3 id=&quot;import&quot;&gt;#import&lt;/h3&gt;

&lt;p&gt;OC特有的就是一个智能的#include，解决了#include的重复包含的问题。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;宏定义&lt;/h2&gt;

&lt;h3 id=&quot;define&quot;&gt;#define&lt;/h3&gt;

&lt;p&gt;这个使用的就太多了，个人认为是所有预处理指令中最酷的！必须要学习！这里我厚颜无耻的转载OneV’s Den(喵神)的文章，他写的非常的棒！&lt;a href=&quot;http://www.onevcat.com/2014/01/black-magic-in-macro/&quot; target=&quot;_blank&quot;&gt;宏定义的黑魔法 - 宏菜鸟起飞手册&lt;/a&gt;，请叫我快乐的搬运工！&lt;/p&gt;

&lt;p&gt;附上那头小牛&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#define NSLog(format, ...)   fprintf(stderr, &quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;,                                           \

[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \

__LINE__, __func__);                                                        \

(NSLog)((format), ##__VA_ARGS__);                                           \

fprintf(stderr, &quot;\n ------------------\n/ Hello David Day! \\\n\\ my Macro Log ~   /\n ------------------\n            \\\n             \\   ^__^\n                 (OO)\__________\n                 (__)\\          )\\/\\\n                     ||_______ _)\n                     ||       W |\n       YYy           ww        ww\n&quot;);



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;图9&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;undef&quot;&gt;#undef&lt;/h3&gt;

&lt;p&gt;当你使用了#define宏定义后，则在整个程序的运行周期内这个宏都是有效的，但有时候我们在某个逻辑里希望这个宏失效不想使用，则会使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#define NetworkOn //定义一个宏，如果该宏定义了，则在应用里使用网络

-(void)closeNetwork{//突然发生意外的情况，网络无法使用了，调用该方法，取消NetworkOn的宏定义
#undef NetworkOn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;条件编译&lt;/h2&gt;

&lt;h3 id=&quot;if-else-endif&quot;&gt;#if #else #endif&lt;/h3&gt;

&lt;p&gt;if就和我们常用的条件语句的if使用方式一样，#if的后面跟上条件表达式，后面跟上一个#endif表示结束#if，虽说这玩意儿简单，但是用的好，对于某些取巧的工作特别容易实现。比如你现在有这样的需求，我的程序平时调试模式的时候需要打印一些log，但是发布模式的应用就不用再打印log了，怎么办？很多人就说发布的时候吧log语句一句一句的删除呗~ 那客户发烂咋说你写的东西是狗屎让你修改，所以你又要回来调试，当你调试的时候你菊花肯定一紧,以前的调试语句因为过于自信在发布的时候全都删除了，又想不到发布后又被要求修改~，有基友就说了，那就不删除log语句呗，反正是打印到控制台的信息，用户又看不到~，果然没有安全意识，企业开发不是学雷锋，不用把你的所有log都写在日记本，有时候你的软件被破解的原因就是因为你的调试信息出卖了你。安全意识不可无，不然老王替你生孩子~~~~~。&lt;/p&gt;

&lt;p&gt;怎么做呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//swift语言&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if DEBUG &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;DEBUG是xcode的预定义的宏，这个东西多的很呢，要慢慢挖掘呢。 以后打印log你都只使用dlog()这个函数，如果你是在调试模式的时候就会打印，否则就不会打印了。&lt;/p&gt;

&lt;p&gt;其他例子：&lt;/p&gt;

&lt;p&gt;判断是否开启ARC，有些库需要ARC支持，则在编译之前可以判断用户有没有开启ARC&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if !__has_feature(objc_arc)
//如果没有开启ARC这里可以做一些错误处理 比如：
#error &quot;啊 啊 啊~ 伦家需要ARC&quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样__has_feature(objc_arc)这玩意儿也是xcode预置的 ， 前缀是这个的”__“都是预定宏；&lt;/p&gt;

&lt;p&gt;又比如，对不同版本的os系统做策略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &amp;lt; __IPHONE_7_0
//如果iOS版本低于7.0，这里可以干一些事情
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又或者判断设备类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
#if IS_IPAD
//这台设备是IPAD呀~~~~
#else
//这货是IPhone
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个东西简单但是很常使用，正所谓IF在手，天下我有 哈哈哈&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt; #if define  #ifdef  #ifndef  #elif
　　#if define = #ifdef

　　#if !define = #ifndef

　　#elif = &quot;else if&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;错误、警告处理&lt;/h2&gt;

&lt;h3 id=&quot;error&quot;&gt;#error&lt;/h3&gt;

&lt;p&gt;如果编译器遇到这货，马上就会罢工。再说Xcode的错误纠正功能这么强大，所以几乎不可能在编译过程中遇到#error了，所以说这货没用？非也~，我们是受过高等教育的高材生，我们要懂得辩证观点还要了解价值定理！任何事物都有存在的价值的。虽说今天的IDE很好很强大，#error似乎没什么用了~但是还有有一群猿类孤高冷傲，隐居山林，他们鄙视一切IDE，他们坚信Notepad就是他们的屠龙宝刀……&lt;/p&gt;

&lt;p&gt;对于这些虚幻飘渺的程序猿们，他们还是需要#error来给他们预报编译前的错误的。我们说点有价值的，如果非要用#error，那在我们当下的开发中怎么用？&lt;/p&gt;

&lt;p&gt;现在#error还是有用的，尤其是你在开发一个库的时候，这个库的使用需要一定的条件，如果不满足这个条件，你就不让使用者编译。这样不就可以使用#error啦嘛&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#if !__has_feature(objc_arc)
#error &quot;我的低调不是你装逼的资本！这个库需要开启ARC，不然你别用！&quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果用户没有开启ARC就无法进行编译了，因为xcode看到#error就不编译了，在这里只有开启了ARC，#error才会不见。&lt;/p&gt;

&lt;h3 id=&quot;warning&quot;&gt;#warning&lt;/h3&gt;

&lt;p&gt;这个用法很简单，只要后面跟上你想警告的话就OK了，这样你就可以让编译器提醒这个警告。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你在Xcode中设置了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图11&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你设置成Yes，那么你的waring就等于error，编译不了的哦。&lt;/p&gt;

&lt;p&gt;请再次叫我快乐的小搬运工~ 又是他 —-&amp;gt;Onev’s Den写的东西，我就是喜欢他，怎么样怎么样？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://onevcat.com/2013/05/talk-about-warning/&quot; target=&quot;_blank&quot;&gt;谈谈Objective-C的警告&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;编译器控制&lt;/h2&gt;

&lt;h3 id=&quot;pragma&quot;&gt;#pragma&lt;/h3&gt;

&lt;p&gt;大家都说在所有的预处理指令中，#Pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。&lt;/p&gt;

&lt;p&gt;其格式一般为: #pragma Para。其中Para 为参数&lt;/p&gt;

&lt;p&gt;我们就说说iOS下，常用的&lt;/p&gt;

&lt;h3 id=&quot;pragma-mark&quot;&gt;#pragma mark&lt;/h3&gt;

&lt;p&gt;如果一个文件代码量很大，有时候找某段逻辑不太好找，你就可以使用#pragma mark！&lt;/p&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图12&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图13&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在方法导航哪里就会出现你的mark了 是不是很方便呀&lt;/p&gt;

&lt;p&gt;如果使用了 “#pragma mark -“ 如这样：&lt;/p&gt;

&lt;h3 id=&quot;pragma-mark--&quot;&gt;#pragma mark -&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;#pragma mark -
#pragma mark 这里是applicationWillTerminate方法呀~
- (void)applicationWillTerminate:(UIApplication *)application {
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会这样，&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图14&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://daiweilai.github.io/img/post/2015-1-20-pic14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自动分隔开了！！！&lt;/p&gt;

&lt;h3 id=&quot;pragma-message&quot;&gt;#pragma message(“”)&lt;/h3&gt;

&lt;p&gt;可以输出调试信息&lt;/p&gt;

&lt;p&gt;控制编译器行为不过多解释了&lt;/p&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-push&quot;&gt;#pragma clang diagnostic push&lt;/h3&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-ignored-clang&quot;&gt;#pragma clang diagnostic ignored “clang的参数”&lt;/h3&gt;

&lt;h3 id=&quot;pragma-clang-diagnostic-pop&quot;&gt;#pragma clang diagnostic pop&lt;/h3&gt;

&lt;p&gt;自行&lt;a href=&quot;http://clang.llvm.org/get_started.html&quot; target=&quot;_blank&quot;&gt;Clang使用手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;pragma非常复杂需要你对编译器底层非常的了解，只有当你开发一些比较底层的framework的时候才可能比较多用的，我是初学者，我不用我怕谁？&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;其他&lt;/h2&gt;

&lt;h3 id=&quot;line&quot;&gt;#line&lt;/h3&gt;

&lt;p&gt;在说这个东西的时候我们先来看一个预定义的宏，&lt;strong&gt;LINE&lt;/strong&gt;，我们在《宏定义的黑魔法 - 宏菜鸟起飞手册》自定义NSLog中见过吧&lt;/p&gt;

&lt;p&gt;C语言中的__LINE__用以指示本行语句在源文件中的位置信息。而#line就是可以改变当前行的行号在编译器中的表示，并且之后的行号也会相应的改变，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;1 #include &amp;lt;stdio.h&amp;gt;
2 main(){
3     printf(&quot;%d\n&quot;,LINE);
4 #line 100  //指定下一行的LINE为100
5     printf(&quot;%d\n&quot;,LINE);
6     printf(&quot;%d\n&quot;,LINE);
7     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;3
100
101
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;　　这篇文章完了~ 这篇文章既是我学习的笔记也是我思考的感悟和一些技术资料的集合，我很用心的写，白天上班写代码，晚上要准备本科的毕业设计，周末陪女朋友，所以我只有在拉屎蹲坑的时候一点一点写出来的，其中一定错漏百出，所以希望看到文章的朋友尽情的喷！砖头不要省！反正我都写代码了我还怕谁？&lt;/p&gt;

&lt;p&gt;　　但是最终嘛，我还是希望能帮到刚刚开始学习的朋友们，毕竟你丫的写的代码太差，也是在污染环境呀！！不是开玩笑！不单单污染环境，你还破坏世界和平，如果你的代码效率很差，你想想如果你的代码运行在电脑上或者手机上那么是不是很费电？费电了是不是要烧很多煤炭来发电？大气中的有害气体是不是越来越多了？温室效应，臭氧层破坏，土地沙漠化，北京沙尘暴，拿钱治理，钱，贪污，腐败，革命，美国参战，朝鲜怒点核武……都怪你！！知道了吧。&lt;/p&gt;

&lt;p&gt;　　还有哦，转载不注明！BUG一生随。你自己看着办&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写代码就是在维护世界和平，谢谢 @戴伟来&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 20 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://externie.github.io/externieblog/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/</link>
        <guid isPermaLink="true">http://externie.github.io/externieblog/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/</guid>
        
        <category>基础整理</category>
        
        <category>预编译</category>
        
        <category>宏定义</category>
        
        
      </item>
    
  </channel>
</rss>
